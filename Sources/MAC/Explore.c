Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"void Explore(void){NavDialogRef				navDialog;NavDialogCreationOptions	navDialogOptions;NavUserAction				navAction;AEKeyword					theKeyword;DescType					actualType;FileReference				selectedFSS;Size						actualSize;NavReplyRecord				navReply;short						err;Str255						name,theStr;void						*fRefNumber,*fRefNumberIn;long						totalWritten,count,i,loaderSelector;Boolean						foundSection;char						PCHeader[]="+------------------+\n|PEFContainerHeader|\n+------------------+\n\n";char						PSHeader[]="+----------------+\n|PEFSectionHeader|\n+----------------+\n\n";char						PLHeader[]="+-------------------+\n|PEFLoaderInfoHeader|\n+-------------------+\n\n";char						HashSlots[]="+-----------------------+\n|ExportedSymbolHashSlots|\n+-----------------------+\n\n";char						ExportKeys[]="+----------------------+\n|ExportedSymbolKeyTable|\n+----------------------+\n\n";char						ExportedSymbols[]="+-------------------+\n|ExportedSymbolTable|\n+-------------------+\n\n";char						RelocationHeader[]="+----------------+\n|RelocationHeader|\n+----------------+\n\n";PEFContainerHeader			containerHeader;PEFSectionHeader			*sectionHeader;PEFLoaderInfoHeader			loaderInfoHeader;PEFExportedSymbolHashSlot	*hashTable;PEFExportedSymbolKey		*exportKeys;PEFExportedSymbol			*exportedSymbols;PEFLoaderRelocationHeader	loaderRelocationHeader;if(gEXPLFileRef){	/*	selectedFSS=(FSSpec*)NewPtr(sizeof(FSSpec));	NavGetDefaultDialogCreationOptions(&navDialogOptions);	NavCreatePutFileDialog(&navDialogOptions,'TEXT','CWIE',nil,nil,&navDialog);	NavDialogRun(navDialog);	navAction = NavDialogGetUserAction(navDialog);	if(navAction==kNavUserActionSaveAs)	{		NavDialogGetReply(navDialog,&navReply);		if(navReply.validRecord)		{		err=AEGetNthPtr(&(navReply.selection),1,typeFSS,&theKeyword,&actualType,selectedFSS,sizeof(FSSpec),&actualSize);		}	}	else	{	selectedFSS = 0;	}	NavDialogDispose(navDialog);	*/	selectedFSS = MyPutFile("\p","\p");	if(selectedFSS)	{	//CFStringGetPascalString(navReply.saveFileName,(unsigned char*)&name,(long)255,(unsigned long)0);	//MyPStrAdd("\p",name,selectedFSS->name);	FSpCreate(selectedFSS,'CWIE','TEXT',smSystemScript);	FSpOpenDF(selectedFSS,fsRdWrPerm,&fRefNumber);	FSpOpenDF(gEXPLFileRef,fsRdPerm,&fRefNumberIn);	totalWritten=0;			count = 64;	FSWrite(fRefNumber,&count,&PCHeader);	totalWritten+=count;		count = 10;	FSWrite(fRefNumber,&count,"tag1\t\t\t\t=\t");	totalWritten+=count;		count=sizeof(PEFContainerHeader);	FSRead(fRefNumberIn,&count,&containerHeader);		count = 4;	FSWrite(fRefNumber,&count,&containerHeader.tag1);	totalWritten+=count;		count = 11;	FSWrite(fRefNumber,&count,"\ntag2\t\t\t\t=\t");	totalWritten+=count;		count = 4;	FSWrite(fRefNumber,&count,&containerHeader.tag2);	totalWritten+=count;		count = 17;	FSWrite(fRefNumber,&count,"\narchitecture\t\t=\t");	totalWritten+=count;		count = 4;	FSWrite(fRefNumber,&count,&containerHeader.architecture);	totalWritten+=count;		count = 18;	FSWrite(fRefNumber,&count,"\nformatVersion\t\t=\t");	totalWritten+=count;		NumToString(containerHeader.formatVersion,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 18;	FSWrite(fRefNumber,&count,"\ndateTimeStamp\t\t=\t");	totalWritten+=count;		NumToString(containerHeader.dateTimeStamp,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 18;	FSWrite(fRefNumber,&count,"\noldDefVersion\t\t=\t");	totalWritten+=count;		NumToString(containerHeader.oldDefVersion,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 18;	FSWrite(fRefNumber,&count,"\noldImpVersion\t\t=\t");	totalWritten+=count;		NumToString(containerHeader.oldImpVersion,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 19;	FSWrite(fRefNumber,&count,"\ncurrentVersion\t\t=\t");	totalWritten+=count;		NumToString(containerHeader.currentVersion,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 17;	FSWrite(fRefNumber,&count,"\nsectionCount\t\t=\t");	totalWritten+=count;		NumToString(containerHeader.sectionCount,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 20;	FSWrite(fRefNumber,&count,"\ninstSectionCount\t=\t");	totalWritten+=count;		NumToString(containerHeader.instSectionCount,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 15;	FSWrite(fRefNumber,&count,"\nreservedA\t\t\t=\t");	totalWritten+=count;		NumToString(containerHeader.reservedA,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;			sectionHeader = (PEFSectionHeader*)NewPtr(sizeof(PEFSectionHeader)*containerHeader.sectionCount);	count = (sizeof(PEFSectionHeader)*containerHeader.sectionCount);	FSRead(fRefNumberIn,&count,sectionHeader);		count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;		for(i=0;i<containerHeader.sectionCount;i++)	{		count = 58;		FSWrite(fRefNumber,&count,&PSHeader);		totalWritten+=count;				count = 15;		FSWrite(fRefNumber,&count,"nameOffset\t\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].nameOffset,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 19;		FSWrite(fRefNumber,&count,"\ndefaultAddress\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].defaultAddress,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 17;		FSWrite(fRefNumber,&count,"\ntotalLength\t\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].totalLength,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 19;		FSWrite(fRefNumber,&count,"\nunpackedLength\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].unpackedLength,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 20;		FSWrite(fRefNumber,&count,"\ncontainerLength\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].containerLength,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 20;		FSWrite(fRefNumber,&count,"\ncontainerOffset\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].containerOffset,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 17;		FSWrite(fRefNumber,&count,"\nsectionKind\t\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].sectionKind,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 15;		FSWrite(fRefNumber,&count,"\nshareKind\t\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].shareKind,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 15;		FSWrite(fRefNumber,&count,"\nalignment\t\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].alignment,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 15;		FSWrite(fRefNumber,&count,"\nreservedA\t\t\t=\t");		totalWritten+=count;				NumToString(sectionHeader[i].reservedA,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 1;		FSWrite(fRefNumber,&count,"\n");		totalWritten+=count;				count = 1;		FSWrite(fRefNumber,&count,"\n");		totalWritten+=count;	}										//---------------Read In Loader Info Header---------------	for(i=0,foundSection=false;i<containerHeader.sectionCount;i++)	{	if(sectionHeader[i].sectionKind == kPEFLoaderSection)	{foundSection=true;break;}	}	if(foundSection)	{	loaderSelector = i;	SetFPos(fRefNumberIn,fsFromStart,sectionHeader[loaderSelector].containerOffset);	count = sizeof(PEFLoaderInfoHeader);	FSRead(fRefNumberIn,&count,&loaderInfoHeader);	}	else	{DebugFunction(gNoLoaderSection);}	//---------------Read In Loader Info Header---------------			count = 67;	FSWrite(fRefNumber,&count,&PLHeader);	totalWritten+=count;	count = 18;	FSWrite(fRefNumber,&count,"mainSection\t\t\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.mainSection,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 18;	FSWrite(fRefNumber,&count,"\nmainOffset\t\t\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.mainOffset,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 19;	FSWrite(fRefNumber,&count,"\ninitSection\t\t\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.initSection,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 18;	FSWrite(fRefNumber,&count,"\ninitOffset\t\t\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.initOffset,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 19;	FSWrite(fRefNumber,&count,"\ntermSection\t\t\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.termSection,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 18;	FSWrite(fRefNumber,&count,"\ntermOffset\t\t\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.termOffset,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 25;	FSWrite(fRefNumber,&count,"\nimportedLibraryCount\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.importedLibraryCount,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 28;	FSWrite(fRefNumber,&count,"\ntotalImportedSymbolCount\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.totalImportedSymbolCount,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 23;	FSWrite(fRefNumber,&count,"\nrelocSectionCount\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.relocSectionCount,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 22;	FSWrite(fRefNumber,&count,"\nrelocInstrOffset\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.relocInstrOffset,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 25;	FSWrite(fRefNumber,&count,"\nloaderStringsOffset\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.loaderStringsOffset,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 22;	FSWrite(fRefNumber,&count,"\nexportHashOffset\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.exportHashOffset,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 25;	FSWrite(fRefNumber,&count,"\nexportHashTablePower\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.exportHashTablePower,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 25;	FSWrite(fRefNumber,&count,"\nexportedSymbolCount\t\t\t=\t");	totalWritten+=count;		NumToString(loaderInfoHeader.exportedSymbolCount,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;		count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;				if(loaderInfoHeader.relocSectionCount==1)	{		SetFPos(fRefNumberIn,fsFromMark,loaderInfoHeader.importedLibraryCount*sizeof(PEFImportedLibrary));		SetFPos(fRefNumberIn,fsFromMark,loaderInfoHeader.totalImportedSymbolCount*sizeof(PEFImportedSymbol));				count=sizeof(PEFLoaderRelocationHeader);		FSRead(fRefNumberIn,&count,&loaderRelocationHeader);				count = 58;		FSWrite(fRefNumber,&count,&RelocationHeader);		totalWritten+=count;						count = 17;		FSWrite(fRefNumber,&count,"\nsectionIndex\t\t=\t");		totalWritten+=count;				NumToString(loaderRelocationHeader.sectionIndex,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 15;		FSWrite(fRefNumber,&count,"\nreservedA\t\t\t=\t");		totalWritten+=count;				NumToString(loaderRelocationHeader.reservedA,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 16;		FSWrite(fRefNumber,&count,"\nrelocCount\t\t\t=\t");		totalWritten+=count;				NumToString(loaderRelocationHeader.relocCount,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 20;		FSWrite(fRefNumber,&count,"\nfirstRelocOffset\t=\t");		totalWritten+=count;				NumToString(loaderRelocationHeader.firstRelocOffset,theStr);		count = theStr[0];		FSWrite(fRefNumber,&count,theStr+1);		totalWritten+=count;				count = 1;		FSWrite(fRefNumber,&count,"\n");		totalWritten+=count;		count = 1;		FSWrite(fRefNumber,&count,"\n");		totalWritten+=count;	}			count = 79;	FSWrite(fRefNumber,&count,&HashSlots);	totalWritten+=count;			hashTable = (PEFExportedSymbolHashSlot*)NewPtr(sizeof(PEFExportedSymbolHashSlot)*_pow(2,loaderInfoHeader.exportHashTablePower));		SetFPos(fRefNumberIn,fsFromStart,sectionHeader[loaderSelector].containerOffset+loaderInfoHeader.exportHashOffset);	count = (sizeof(PEFExportedSymbolHashSlot)*_pow(2,loaderInfoHeader.exportHashTablePower));	FSRead(fRefNumberIn,&count,hashTable);		for(i=0;i<_pow(2,loaderInfoHeader.exportHashTablePower);i++)	{	NumToString(hashTable[i].countAndStart,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;	count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	}			exportKeys = (PEFExportedSymbolKey*)NewPtr(sizeof(PEFExportedSymbolKey)*loaderInfoHeader.exportedSymbolCount);	count = (sizeof(PEFExportedSymbolKey)*loaderInfoHeader.exportedSymbolCount);	FSRead(fRefNumberIn,&count,exportKeys);				count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	count = 76;	FSWrite(fRefNumber,&count,&ExportKeys);	totalWritten+=count;		for(i=0;i<loaderInfoHeader.exportedSymbolCount;i++)	{	NumToString(exportKeys[i].u.fullHashWord,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;	count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	}						exportedSymbols = (PEFExportedSymbol*)NewPtr(sizeof(PEFExportedSymbol)*loaderInfoHeader.exportedSymbolCount);	count = (sizeof(PEFExportedSymbol)*loaderInfoHeader.exportedSymbolCount);	FSRead(fRefNumberIn,&count,exportedSymbols);			count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	count = 67;	FSWrite(fRefNumber,&count,&ExportedSymbols);	totalWritten+=count;			for(i=0;i<loaderInfoHeader.exportedSymbolCount;i++)	{	count = 15;	FSWrite(fRefNumber,&count,"classAndName\t=\t");	totalWritten+=count;	NumToString(exportedSymbols[i].classAndName,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;	count = 16;	FSWrite(fRefNumber,&count,"\nsymbolValue\t\t=\t");	totalWritten+=count;	NumToString(exportedSymbols[i].symbolValue,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;	count = 16;	FSWrite(fRefNumber,&count,"\nsectionIndex\t=\t");	totalWritten+=count;	NumToString(exportedSymbols[i].sectionIndex,theStr);	count = theStr[0];	FSWrite(fRefNumber,&count,theStr+1);	totalWritten+=count;	count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	count = 1;	FSWrite(fRefNumber,&count,"\n");	totalWritten+=count;	}					SetEOF(fRefNumber,totalWritten);	FSClose(fRefNumber);	FSClose(fRefNumberIn);	}}}