Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"long 						lineNum;unsigned char				*fileName;#define GET_8BIT																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0xFF)																												\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_8BIT_M1																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x100)																												\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_22BIT																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x003FFFFF)																											\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_26BIT																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x03FFFFFF)																											\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_6BIT																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x3F)																												\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_4BIT																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0xF)																													\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_4BIT_M1																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x10)																												\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_9BIT																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x1FF)																												\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_9BIT_M1																											\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x200)																												\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}#define GET_12BIT_M1																										\																															\while(!(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39)){(*asmPB->bMarker)++;}		\bmHolder = (*asmPB->bMarker);																								\while(asmPB->asmBuffer[(*asmPB->bMarker)]>=0x30 && asmPB->asmBuffer[(*asmPB->bMarker)]<=0x39){(*asmPB->bMarker)++;}			\arg = 0;																													\j = (*asmPB->bMarker) - bmHolder;																							\j--;																														\(*asmPB->bMarker) = bmHolder;																								\for(;j>=0;(*asmPB->bMarker)++,j--)																							\{																															\arg += ((asmPB->asmBuffer[(*asmPB->bMarker)]-0x30)*(_pow(10,j)));															\}																															\if(arg>0x1000)																												\{																															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",fileName,gTempTxt2);									\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																					\NumberToString(lineNum,(char*)gTempTxt3);																					\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																					\DebugFunction(gTempTxt2);																									\}void AssembleRelocations(AssemblerRecord	*asmRecord){void				*fRefNumber;long				dataSize;unsigned long		count;char				tempBuffer[255];long				i,j,k;AssemblyPBlock		asmPB;long				compatL=0;fileName = (unsigned char*)NewPtr(255);FileRef_GetFileName(asmRecord->key->reloc,fileName);FSpOpenDF(asmRecord->key->reloc,fsRdPerm,&fRefNumber);GetEOF(fRefNumber,&dataSize);asmPB.asmBuffer = NewPtr(dataSize+8);count = dataSize;FSRead(fRefNumber,&count,asmPB.asmBuffer);FSClose(fRefNumber);for(i=0,j=0;i<dataSize;i++){if(asmPB.asmBuffer[i]=='\r'){j++;}}asmPB.relocs = (short*)NewPtr((j*8));//hopefully that is enough padding...asmPB.rMarker=0;for(i=0;i<(j*8);i++){((char*)asmPB.relocs)[i]=0;}asmPB.bMarker = &compatL;asmPB.asmRecord = asmRecord;(*asmPB.bMarker)=0;lineNum=1;while(*asmPB.bMarker<dataSize){	switch(asmPB.asmBuffer[*asmPB.bMarker])	{	case ' ' :	case '\t':	case '\n':	case '\r':lineNum++;(*asmPB.bMarker)++;break;	case '#':while(asmPB.asmBuffer[*asmPB.bMarker]!=0x0D){(*asmPB.bMarker)++;}break;	default:{			i=1;			while((asmPB.asmBuffer[*asmPB.bMarker]!=0x09) && (asmPB.asmBuffer[*asmPB.bMarker]!=0x20) && (asmPB.asmBuffer[*asmPB.bMarker]!=0x0D))			{			tempBuffer[i] = asmPB.asmBuffer[*asmPB.bMarker];			(*asmPB.bMarker)++;			i++;			}			tempBuffer[0] = (i-1);			i=0;						switch(tempBuffer[i])			{				case 3:				{					i++;					switch(tempBuffer[i])					{						case 'R':						{							i++;							switch(tempBuffer[i])							{								case 'P':								{									i++;									switch(tempBuffer[i])									{										case 'T':										{											RPT(&asmPB);											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								default: Byte_ILLEGAL(&asmPB);							}							break;						}					}					break;				}				case 4:				{					i++;					switch(tempBuffer[i])					{						case 'C':						{							i++;							switch(tempBuffer[i])							{								case 'D':								{									i++;									switch(tempBuffer[i])									{										case 'I':										{											i++;											switch(tempBuffer[i])											{												case 'S':												{													CDIS(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'O':								{									i++;									switch(tempBuffer[i])									{										case 'D':										{											i++;											switch(tempBuffer[i])											{												case 'E':												{													CODE(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								default: Byte_ILLEGAL(&asmPB);							}							break;						}						case 'D':						{							i++;							switch(tempBuffer[i])							{								case 'A':								{									i++;									switch(tempBuffer[i])									{										case 'T':										{											i++;											switch(tempBuffer[i])											{												case 'A':												{													DATA(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'D':								{									i++;									switch(tempBuffer[i])									{										case 'A':										{											i++;											switch(tempBuffer[i])											{												case 'T':												{													DDAT(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'E':								{									i++;									switch(tempBuffer[i])									{										case 'L':										{											i++;											switch(tempBuffer[i])											{												case 'T':												{													DELT(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										case 'S':										{											i++;											switch(tempBuffer[i])											{												case 'C':												{													DESC(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'S':								{									i++;									switch(tempBuffer[i])									{										case 'C':										{											i++;											switch(tempBuffer[i])											{												case '2':												{													DSC2(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'T':								{									i++;									switch(tempBuffer[i])									{										case 'I':										{											i++;											switch(tempBuffer[i])											{												case 'S':												{													DTIS(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								default: Byte_ILLEGAL(&asmPB);							}							break;						}						case 'L':						{							i++;							switch(tempBuffer[i])							{								case 'A':								{									i++;									switch(tempBuffer[i])									{										case 'B':										{											i++;											switch(tempBuffer[i])											{												case 'S':												{													LABS(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'R':								{									i++;									switch(tempBuffer[i])									{										case 'P':										{											i++;											switch(tempBuffer[i])											{												case 'T':												{													LRPT(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'S':								{									i++;									switch(tempBuffer[i])									{										case 'E':										{											i++;											switch(tempBuffer[i])											{												case 'C':												{													LSEC(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										case 'Y':										{											i++;											switch(tempBuffer[i])											{												case 'M':												{													LSYM(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								default: Byte_ILLEGAL(&asmPB);							}							break;						}						case 'S':						{							i++;							switch(tempBuffer[i])							{								case 'E':								{									i++;									switch(tempBuffer[i])									{										case 'C':										{											i++;											switch(tempBuffer[i])											{												case 'N':												{													SECN(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								case 'Y':								{									i++;									switch(tempBuffer[i])									{										case 'M':										{											i++;											switch(tempBuffer[i])											{												case 'B':												{													SYMB(&asmPB);													break;												}												case 'R':												{													SYMR(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								default: Byte_ILLEGAL(&asmPB);							}							break;						}						case 'V':						{							i++;							switch(tempBuffer[i])							{								case 'T':								{									i++;									switch(tempBuffer[i])									{										case 'B':										{											i++;											switch(tempBuffer[i])											{												case 'L':												{													VTBL(&asmPB);													break;												}												default: Byte_ILLEGAL(&asmPB);											}											break;										}										default: Byte_ILLEGAL(&asmPB);									}									break;								}								default: Byte_ILLEGAL(&asmPB);							}							break;						}					}					break;				}				default:break;			}															//			DisposePtr(slam);			break;			}	}}DisposePtr(asmPB.asmBuffer);//asmRecord->relocs = (short*)NewPtr((j*2)+8);//for(i=0;i<(j*2)+8;i++){((char*)asmRecord->relocs)[i]=((char*)asmPB.relocs)[i];}asmRecord->relocs = asmPB.relocs;asmRecord->reloccount = asmPB.rMarker;DisposePtr((char*)fileName);}void DDAT(AssemblyPBlock  *asmPB){long arg,j,bmHolder;GET_8BITasmPB->relocs[asmPB->rMarker] += arg<<6;GET_6BITasmPB->relocs[asmPB->rMarker] += arg;asmPB->rMarker++;}void CODE(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x20<<9;GET_9BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void DATA(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x21<<9;GET_9BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void DESC(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x22<<9;GET_9BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void DSC2(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x23<<9;GET_9BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void VTBL(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x24<<9;GET_9BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void SYMR(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x25<<9;GET_9BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void SYMB(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x30<<9;GET_9BITasmPB->relocs[asmPB->rMarker] += arg;asmPB->rMarker++;}void CDIS(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x31<<9;GET_9BITasmPB->relocs[asmPB->rMarker] += arg;asmPB->rMarker++;}void DTIS(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x32<<9;GET_9BITasmPB->relocs[asmPB->rMarker] += arg;asmPB->rMarker++;}void SECN(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x33<<9;GET_9BITasmPB->relocs[asmPB->rMarker] += arg;asmPB->rMarker++;}void DELT(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 8<<12;GET_12BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void RPT(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 9<<12;GET_4BIT_M1asmPB->relocs[asmPB->rMarker] += (arg-1)<<8;GET_8BIT_M1asmPB->relocs[asmPB->rMarker] += arg-1;asmPB->rMarker++;}void LABS(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x28<<10;GET_26BITasmPB->relocs[asmPB->rMarker] += (arg&0x03FF0000)>>16;asmPB->rMarker++;asmPB->relocs[asmPB->rMarker] += arg&0xFFFF;asmPB->rMarker++;}void LSYM(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x29<<10;GET_26BITasmPB->relocs[asmPB->rMarker] += (arg&0x03FF0000)>>16;asmPB->rMarker++;asmPB->relocs[asmPB->rMarker] += arg&0xFFFF;asmPB->rMarker++;}void LRPT(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x2C<<10;GET_4BIT_M1asmPB->relocs[asmPB->rMarker] += (arg-1)<<10;GET_22BITasmPB->relocs[asmPB->rMarker] += (arg&0x003F0000)>>16;asmPB->rMarker++;asmPB->relocs[asmPB->rMarker] += arg&0xFFFF;asmPB->rMarker++;}void LSEC(AssemblyPBlock  *asmPB){long arg,j,bmHolder;asmPB->relocs[asmPB->rMarker] += 0x2D<<10;GET_4BITasmPB->relocs[asmPB->rMarker] += arg<<10;GET_22BITasmPB->relocs[asmPB->rMarker] += (arg&0x003F0000)>>16;asmPB->rMarker++;asmPB->relocs[asmPB->rMarker] += arg&0xFFFF;asmPB->rMarker++;}