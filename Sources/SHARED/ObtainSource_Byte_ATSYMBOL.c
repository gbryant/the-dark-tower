Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define WHITE_SPACE(X,Y)	\(							\(X[Y]=='\t')				\||							\(X[Y]=='\r')				\||							\(X[Y]=='\n')				\||							\(X[Y]==' ')					\||							\(X[Y]=='#')					\||							\(X[Y]==',')					\||							\(X[Y]=='|')					\||							\(X[Y]==']')					\||							\(X[Y]==':')					\)#define INCREMENT(X)										\X++;														\gSrcPosAccum++;												\if(X==(*asmPB->asmBSize))									\{															\fRead=true;													\asmPB->sCount = (*asmPB->asmBSize);							\FSRead(asmPB->fRefNumber,&asmPB->sCount,asmPB->asmBuffer);	\(*asmPB->asmBSize) = asmPB->sCount;							\X=0;														\}void ObtainSource_Byte_ATSYMBOL(AssemblyPBlock* asmPB){long				i,bmHolder,tempDataSize,dataSize;Boolean				weak=false,fRead=false;long				fPos;Str255				dataHolder;void				*err;i=1;INCREMENT((*asmPB->bMarker))while(!WHITE_SPACE(asmPB->asmBuffer,(*asmPB->bMarker))&&asmPB->sCount){dataHolder[i] = asmPB->asmBuffer[(*asmPB->bMarker)];i++;INCREMENT((*asmPB->bMarker))}dataHolder[0] = i-1;if(MyPStrCmp(dataHolder,"\pImport") || MyPStrCmp(dataHolder,"\p_Import")){	if(MyPStrCmp(dataHolder,"\p_Import")){weak=true;}	if(!(asmPB->currImpRec)){(asmPB->currImpRec) = &asmPB->asmRecord->import;}	else	{	(asmPB->currImpRec)->next = (ImportRecord*)NewPtr(sizeof(ImportRecord));	(asmPB->currImpRec)->next->prev = asmPB->currImpRec;	(asmPB->currImpRec)->next->next = nil;	(asmPB->currImpRec) = asmPB->currImpRec->next;	}			while(WHITE_SPACE(asmPB->asmBuffer,(*asmPB->bMarker))){INCREMENT((*asmPB->bMarker))}	i=1;	while(!WHITE_SPACE(asmPB->asmBuffer,(*asmPB->bMarker)))	{	dataHolder[i] = asmPB->asmBuffer[(*asmPB->bMarker)];	i++;	INCREMENT((*asmPB->bMarker))	}	dataHolder[0] = i-1;	(asmPB->currImpRec)->lib = NewPtr(dataHolder[0]+1);	for(i=0;i<dataHolder[0];i++)	{	(asmPB->currImpRec)->lib[i] = dataHolder[i+1];	}	(asmPB->currImpRec)->lib[i] = '\0';	if(weak)	{(asmPB->currImpRec)->weak = true;}	else	{(asmPB->currImpRec)->weak = false;}	(asmPB->currImpRec)->init = false;	(asmPB->currImpRec)->symcount = 0;	while(asmPB->asmBuffer[(*asmPB->bMarker)]!='{')	{	if(asmPB->asmBuffer[(*asmPB->bMarker)]=='\r'){asmPB->lineNum++;}	INCREMENT((*asmPB->bMarker))	}	INCREMENT((*asmPB->bMarker))				fRead=false;	GetFPos(asmPB->fRefNumber,&fPos);	fPos-=(*asmPB->asmBSize);	fPos+=(*asmPB->bMarker);	bmHolder = (*asmPB->bMarker);				tempDataSize=0;	while(asmPB->asmBuffer[(*asmPB->bMarker)]!='}')	{		switch(asmPB->asmBuffer[(*asmPB->bMarker)])		{			case '#':			{			while(asmPB->asmBuffer[(*asmPB->bMarker)]!='\r'){INCREMENT((*asmPB->bMarker))}			break;			}			case ' ':			case '\t':			{			INCREMENT((*asmPB->bMarker))			break;			}			case '\r':			{			asmPB->lineNum++;			INCREMENT((*asmPB->bMarker))			break;			}			default:			{			(asmPB->currImpRec)->symcount++;			while(asmPB->asmBuffer[(*asmPB->bMarker)]!='\r' && asmPB->asmBuffer[(*asmPB->bMarker)]!='#')			{			tempDataSize++;			INCREMENT((*asmPB->bMarker))			}			tempDataSize++;//for the null 0 needed			break;			}		}	}				if(fRead)	{	SetFPos(asmPB->fRefNumber,fsFromStart,fPos);	asmPB->sCount = (*asmPB->asmBSize);	FSRead(asmPB->fRefNumber,&asmPB->sCount,asmPB->asmBuffer);	(*asmPB->asmBSize) = asmPB->sCount;	(*asmPB->bMarker)=0;	}	else	{(*asmPB->bMarker) = bmHolder;}			i=0;	(asmPB->currImpRec)->sym = NewPtr(tempDataSize);	while(asmPB->asmBuffer[(*asmPB->bMarker)]!='}')	{		switch(asmPB->asmBuffer[(*asmPB->bMarker)])		{			case '#':			{			while(asmPB->asmBuffer[(*asmPB->bMarker)]!='\r'){INCREMENT((*asmPB->bMarker))}			break;			}			case ' ':			case '\t':			case '\r':			{			INCREMENT((*asmPB->bMarker))			break;			}			default:			{			while(asmPB->asmBuffer[(*asmPB->bMarker)]!='\r' && asmPB->asmBuffer[(*asmPB->bMarker)]!='#')			{			(asmPB->currImpRec)->sym[i] = asmPB->asmBuffer[(*asmPB->bMarker)];			INCREMENT((*asmPB->bMarker));i++;			}			(asmPB->currImpRec)->sym[i] = '\0';			i++;			break;			}		}	}	INCREMENT((*asmPB->bMarker))}else if(MyPStrCmp(dataHolder,"\pmain")){asmPB->asmRecord->main = (asmPB->asmRecord->instcount+asmPB->asmRecord->instaccum)*4;}else if(MyPStrCmp(dataHolder,"\pinit")){asmPB->asmRecord->init = (asmPB->asmRecord->instcount+asmPB->asmRecord->instaccum)*4;}else if(MyPStrCmp(dataHolder,"\pterm")){asmPB->asmRecord->term = (asmPB->asmRecord->instcount+asmPB->asmRecord->instaccum)*4;}else if(MyPStrCmp(dataHolder,"\pdata")){DirectDataIncluder(asmPB);}else if(MyPStrCmp(dataHolder,"\pDefine")){while(asmPB->asmBuffer[(*asmPB->bMarker)]!='}'){if(asmPB->asmBuffer[(*asmPB->bMarker)]=='\r'){asmPB->lineNum++;}INCREMENT((*asmPB->bMarker))}INCREMENT((*asmPB->bMarker))//MacroDefiner(asmPB);}else if(MyPStrCmp(dataHolder,"\pExport")){if(!(asmPB->currExpRec)){(asmPB->currExpRec) = &asmPB->asmRecord->exports;}else{(asmPB->currExpRec)->next = (ExportRecord*)NewPtr(sizeof(ExportRecord));(asmPB->currExpRec)->next->prev = asmPB->currExpRec;(asmPB->currExpRec)->next->next = nil;(asmPB->currExpRec) = asmPB->currExpRec->next;}while(WHITE_SPACE(asmPB->asmBuffer,(*asmPB->bMarker))){INCREMENT((*asmPB->bMarker))}i=1;while(!WHITE_SPACE(asmPB->asmBuffer,(*asmPB->bMarker))){dataHolder[i] = asmPB->asmBuffer[(*asmPB->bMarker)];i++;INCREMENT((*asmPB->bMarker))}dataHolder[0] = i-1;(asmPB->currExpRec)->label = NewPtr(dataHolder[0]+1);for(i=0;i<dataHolder[0];i++){(asmPB->currExpRec)->label[i] = dataHolder[i+1];}(asmPB->currExpRec)->label[i] = '\0';(asmPB->currExpRec)->offset = asmPB->asmRecord->instcount*4;}else if(MyPStrCmp(dataHolder,"\pSectionD")){while(asmPB->asmBuffer[(*asmPB->bMarker)]!='}'){if(asmPB->asmBuffer[(*asmPB->bMarker)]=='\r'){asmPB->lineNum++;}INCREMENT((*asmPB->bMarker))}INCREMENT((*asmPB->bMarker))}else if(MyPStrCmp(dataHolder,"\pInclude")){			i=1;	while(!(asmPB->asmBuffer[(*asmPB->bMarker)]=='"'))	{	INCREMENT((*asmPB->bMarker))	}	INCREMENT((*asmPB->bMarker))	while(!(asmPB->asmBuffer[(*asmPB->bMarker)]=='"'))	{	dataHolder[i] = asmPB->asmBuffer[(*asmPB->bMarker)];	i++;	INCREMENT((*asmPB->bMarker))	}	dataHolder[0] = i-1;	INCREMENT((*asmPB->bMarker))		GetFPos(asmPB->fRefNumber,&asmPB->isRecord[asmPB->depth].pos);	asmPB->isRecord[asmPB->depth].pos-=(*asmPB->asmBSize);	asmPB->isRecord[asmPB->depth].pos+=(*asmPB->bMarker);		asmPB->isRecord[asmPB->depth].lineNum = asmPB->lineNum;	asmPB->lineNum=1;		FileRef_To_FileRef_Copy(asmPB->currSrc,asmPB->isRecord[asmPB->depth].file);	FileRef_To_FileRef_NewName(asmPB->currSrc,dataHolder,asmPB->currSrc);			FSClose(asmPB->fRefNumber);				err = FSpOpenDF(asmPB->currSrc,fsRdPerm,&asmPB->fRefNumber);	if(CheckError_FSpOpenDF(err)){DebugFunction("\pFile System Error");}			//еееееееееееееее		//asmPB->sCount=(*asmPB->asmBSize);	asmPB->sCount=BUFFER_SIZE;	FSRead(asmPB->fRefNumber,&asmPB->sCount,asmPB->asmBuffer);		//еееееееееееееее		(*asmPB->asmBSize)=asmPB->sCount;	(*asmPB->bMarker)=0;	asmPB->depth++;}else{FileRef_GetFileName(asmPB->currSrc,gTempTxt3);MyPStrAdd("\pIllegal @SectionD directive\rSource: ",gTempTxt3,gTempTxt2);MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);NumberToString(asmPB->lineNum,(char*)gTempTxt3);MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);DebugFunction(gTempTxt2);}}