Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define BUFF_SIZE 0x210000#define SetFPos_(X,Y,Z)\if(Y==fsFromStart){theFilePointer=Z;}\else if(Y==fsFromMark){theFilePointer+=Z;}#define FSRead_(X,Y,Z)\for(countermodread=0;countermodread<(*Y);countermodread++)\{((unsigned char*)(Z))[countermodread]=( (unsigned char*)( ((unsigned char*)(X))+theFilePointer ) )[countermodread];}\theFilePointer+=countermodread;//FSRead_(appref,&count,appPEF.sectionHeader);#define _ExtractArgument(X)						\X=0;											\while(dataSectionC[dataCM]&0x80)				\{												\X += dataSectionC[dataCM]&0x7F;					\X <<= 7;										\dataCM++;										\}												\X += dataSectionC[dataCM]&0x7F;					\dataCM++;#define	INTEL_NAME_APPEND(X,Y)												\																			\ZeroMemory(&Y,MAX_PATH);													\i=0;																		\while(((char*)destRef)[i]!=0){Y[i] = ((char*)destRef)[i];i++;}				\Y[i]=0;																		\i=0;while(((char*)fref)[i]!=0){i++;}										\while(((char*)fref)[i]!='\\'){i--;}a=i+1;									\i=0;while(((char*)Y)[i]!=0){i++;}((char*)Y)[i]='\\';i++;					\while(((char*)fref)[a]!=0){((char*)Y)[i] = ((char*)fref)[a];i++;a++;}		\for(a=0;a<(sizeof(X)-1);a++,i++){((char*)Y)[i]=X[a];}						\((char*)Y)[i]=0;#define POWERPC_NAME_APPEND(X,Y)  																	\																									\MyPStrAdd("\pgeneric",X,tempPStr1);																	\MyPStrAdd("\p:",tempPStr1,tempPStr2);																\MyPStrAdd(((FSSpec*)destRef)->name,tempPStr2,tempPStr1);											\MyPStrAdd("\p:",tempPStr1,tempPStr2);																\FSMakeFSSpec(((FSSpec*)destRef)->vRefNum,((FSSpec*)destRef)->parID,tempPStr2,Y);	void DisassembleCFragM(void	*fref, void	*destRef){PEFContainer					appPEF;RelocOpWriterPBlock				rowPB;short							resAttr;LabelListPBlock					llPB;MnemonicWriterPBlock			mwPB;long							i,a,j,k,m,n,blockSize,commonSize,customSize,repeatCount,dataCM,dataEM,dataCMHolder;Boolean							foundSection,needsExpansion;Str255							tempPStr1,tempPStr2;long							totalWritten,bm;long							dataSelector,codeSelector,loaderSelector;Str255							resFName,resName;short							resCount;Handle							resHandle;short							resRefIn,resRefOut,typeCount;short							resID;long							dSizes;char							*dataSectionC=0;char							*dataSectionE=0,*buffer;unsigned short					*relocSection;char							*commonData;long							*codeSection;PEFImportedLibrary				*impLib;PEFImportedSymbol				*impSym;char							*loaderNameTable;PEFExportedSymbolHashSlot		*exSymHash;PEFExportedSymbolKey			*exSymKey;PEFExportedSymbol				*exSym;DataExport						*expData,**currExpData,*currEDd;CodeExport						*expCode,**currExpCode,*currCDd;void							*appref;void							*outFRef;LabelList						*thenow,*forbye;Rect							winBound;FragPoint						fragPoint;long							temp;Boolean							boolVal;Str255 							winTitle;KeyFilePB						keyfilePB;unsigned long					count;FSRef 			        		newRef;KeyMap							keyMap;FSCatalogInfo 					catInfo;ResType							resType;//FSSpec						*outFile;FileReference					dataSectionFile=0;FileReference					relocSectionFile=0;FileReference					codeSectionFile=0;FileReference					resourceSectionFile=0;FileReference					placeHolder;Str255							appName,appNameWExt;#ifdef __INTEL__long							cyVScroll;HWND							winProgBar;HWND							statText;RECT							winRect;#endifunsigned long			theFilePointer,countermodread;long zzz;dataSectionFile = FileRef_Allocate();relocSectionFile = FileRef_Allocate();codeSectionFile = FileRef_Allocate();resourceSectionFile = FileRef_Allocate();FileRef_GetFileName(fref,appName);placeHolder=FileRef_Allocate();FileRef_To_FileRef_InDirectory(destRef,appName,placeHolder);//FSpOpenDF(fref,fsRdPerm,&appref);appref=fref;SetFPos_(appref,fsFromStart,0);theFilePointer=0;count = sizeof(PEFContainerHeader);FSRead_(appref,&count,&appPEF.containerHeader);#ifdef __INTEL__Swap_PEF_CONTAINER_HEADER(&appPEF.containerHeader);#endifcount = sizeof(PEFSectionHeader)*appPEF.containerHeader.sectionCount;appPEF.sectionHeader = (PEFSectionHeader*)NewPtr(count);FSRead_(appref,&count,appPEF.sectionHeader);#ifdef __INTEL__for(i=0;i<appPEF.containerHeader.sectionCount;i++){Swap_PEF_SECTION_HEADER(&appPEF.sectionHeader[i]);}#endiffor(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFCodeSection){foundSection=true;break;}}if(foundSection){codeSelector = i;}else{for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFExecDataSection){foundSection=true;break;}}if(foundSection){codeSelector = i;}else{DebugFunction(gNoCodeSection);}}#ifdef __POWERPC__SetControl32BitMaximum(gAppControls.progressBar,((appPEF.sectionHeader[codeSelector].containerLength/4)/1000));boolVal=true;SetControlData(gAppControls.progressBar,kControlEntireControl,kControlProgressBarIndeterminateTag,sizeof(Boolean),&boolVal);SetControlData(gAppControls.statusText, kControlEditTextPart,kControlStaticTextTextTag,sizeof("      Gathering Data...")-1,"      Gathering Data...");TransitionWindow(gAppWindow,kWindowZoomTransitionEffect,kWindowShowTransitionAction,NULL);DrawControls(gAppWindow);ReceiveNextEvent(0,NULL,kEventWaitTime,false,NULL);#endif#ifdef __INTEL__cyVScroll = GetSystemMetrics(SM_CYHSCROLL);InitCommonControls();GetClientRect(gHwnd,&winRect);winProgBar = CreateWindowEx(0,PROGRESS_CLASS,0,WS_CHILD|WS_VISIBLE,winRect.left,winRect.bottom-cyVScroll,winRect.right,cyVScroll,gHwnd,(HMENU)0,(HINSTANCE)0,0);statText = CreateWindowEx(0,"Static",0,WS_CHILD|WS_VISIBLE|SS_CENTER,winRect.left,winRect.bottom-winRect.bottom/2,winRect.right,50,gHwnd,(HMENU)0,(HINSTANCE)0,0);//SendMessage(statText,TVM_SETBKCOLOR,0,RGB(255,255,255));//SetBkColor(GetDC(gHwnd),RGB(255,0,0));SendMessage(winProgBar,PBM_SETRANGE32,0,((appPEF.sectionHeader[codeSelector].containerLength/4)/1000));SendMessage(winProgBar,PBM_SETSTEP,1,0);//SendMessage(winProgBar,PBM_STEPIT,0,0);#endif//---------------Read In Loader Info Header---------------for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFLoaderSection){foundSection=true;break;}}if(foundSection){loaderSelector = i;SetFPos_(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset);count = sizeof(PEFLoaderInfoHeader);FSRead_(appref,&count,&appPEF.loaderInfoHeader);#ifdef __INTEL__Swap_PEF_LOADER_INFO_HEADER(&appPEF.loaderInfoHeader);#endif}else{DebugFunction(gNoLoaderSection);}//---------------Read In Loader Info Header---------------//---SetFPos_(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset);SetFPos_(appref,fsFromMark,sizeof(PEFLoaderInfoHeader));impLib=(PEFImportedLibrary*)NewPtr(sizeof(PEFImportedLibrary)*appPEF.loaderInfoHeader.importedLibraryCount);impSym=(PEFImportedSymbol*)NewPtr(sizeof(PEFImportedSymbol)*appPEF.loaderInfoHeader.totalImportedSymbolCount);count = sizeof(PEFImportedLibrary)*appPEF.loaderInfoHeader.importedLibraryCount;FSRead_(appref,&count,impLib);#ifdef __INTEL__for(i=0;i<appPEF.loaderInfoHeader.importedLibraryCount;i++)Swap_PEF_IMPORTED_LIBRARY(&impLib[i]);#endifcount = sizeof(PEFImportedSymbol)*appPEF.loaderInfoHeader.totalImportedSymbolCount;FSRead_(appref,&count,impSym);#ifdef __INTEL__for(i=0;i<appPEF.loaderInfoHeader.totalImportedSymbolCount;i++)Swap_LONG(&impSym[i].classAndName);#endifloaderNameTable = NewPtr(appPEF.sectionHeader[loaderSelector].containerLength-appPEF.loaderInfoHeader.loaderStringsOffset);SetFPos_(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+appPEF.loaderInfoHeader.loaderStringsOffset);count = appPEF.sectionHeader[loaderSelector].containerLength - appPEF.loaderInfoHeader.loaderStringsOffset;FSRead_(appref,&count,loaderNameTable);//Read in the export stuff hereexpCode=nil;expData=nil;if(appPEF.loaderInfoHeader.exportedSymbolCount){	SetFPos_(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+appPEF.loaderInfoHeader.exportHashOffset);	exSymHash = (PEFExportedSymbolHashSlot*)NewPtr(sizeof(PEFExportedSymbolHashSlot) * (_pow(2,appPEF.loaderInfoHeader.exportHashTablePower)));	count = sizeof(PEFExportedSymbolHashSlot) * (_pow(2,appPEF.loaderInfoHeader.exportHashTablePower));	FSRead_(appref,&count,exSymHash);	#ifdef __INTEL__	for(i=0;i<sizeof(PEFExportedSymbolHashSlot) * (_pow(2,appPEF.loaderInfoHeader.exportHashTablePower));i++)Swap_LONG(&exSymHash[i].countAndStart);	#endif	exSymKey = (PEFExportedSymbolKey*)NewPtr(sizeof(PEFExportedSymbolKey) * (appPEF.loaderInfoHeader.exportedSymbolCount));	count = sizeof(PEFExportedSymbolKey) * (appPEF.loaderInfoHeader.exportedSymbolCount);	FSRead_(appref,&count,exSymKey);	#ifdef __INTEL__	for(i=0;i<sizeof(PEFExportedSymbolKey) * (appPEF.loaderInfoHeader.exportedSymbolCount);i++)Swap_LONG(&exSymKey[i].u.fullHashWord);	#endif	exSym = (PEFExportedSymbol*)NewPtr(sizeof(PEFExportedSymbol)*appPEF.loaderInfoHeader.exportedSymbolCount);	count = sizeof(PEFExportedSymbol)*appPEF.loaderInfoHeader.exportedSymbolCount;	FSRead_(appref,&count,exSym);	#ifdef __INTEL__	for(i=0;i<sizeof(PEFExportedSymbol)*appPEF.loaderInfoHeader.exportedSymbolCount;i++)Swap_PEF_EXPORTED_SYMBOL(&exSym[i]);	#endif	//expCode=nil;	//expData=nil;	currExpCode = &expCode;	currExpData = &expData;	for(i=0;i<appPEF.loaderInfoHeader.exportedSymbolCount;i++)	{		if(exSym[i].sectionIndex==1)		{		(*currExpData) = (DataExport*)NewPtr(sizeof(DataExport));		(*currExpData)->next=nil;		(*currExpData)->offset = exSym[i].symbolValue;		j = exSymKey[i].u.splitHashWord.nameLength;		(*currExpData)->label = NewPtr(j+1);		for(k=0;k<j;k++){(*currExpData)->label[k+1]=loaderNameTable[PEFExportedSymbolNameOffset(exSym[i].classAndName)+k];}		(*currExpData)->label[0]=j;		currExpData = &((*currExpData)->next);		}		else if(exSym[i].sectionIndex==0)		{		(*currExpCode) = (CodeExport*)NewPtr(sizeof(CodeExport));		(*currExpCode)->next=nil;		(*currExpCode)->offset = exSym[i].symbolValue;		j = exSymKey[i].u.splitHashWord.nameLength;		(*currExpCode)->label = NewPtr(j+1);		for(k=0;k<j;k++){(*currExpCode)->label[k+1]=loaderNameTable[PEFExportedSymbolNameOffset(exSym[i].classAndName)+k];}		(*currExpCode)->label[0]=j;		currExpCode = &((*currExpCode)->next);		}	}DisposePtr((char*)exSymHash);DisposePtr((char*)exSymKey);DisposePtr((char*)exSym);}//security for laziness ;)    ½if(appPEF.loaderInfoHeader.relocSectionCount!=1){DebugFunction(gMultipleRelocations);}//---------------Read In Relocations---------------SetFPos_(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset);SetFPos_(appref,fsFromMark,sizeof(PEFLoaderInfoHeader));SetFPos_(appref,fsFromMark,sizeof(PEFImportedLibrary)*appPEF.loaderInfoHeader.importedLibraryCount);SetFPos_(appref,fsFromMark,sizeof(PEFImportedSymbol)*appPEF.loaderInfoHeader.totalImportedSymbolCount);appPEF.loaderRelocationHeader = (PEFLoaderRelocationHeader*)NewPtr(sizeof(PEFLoaderRelocationHeader));count = sizeof(PEFLoaderRelocationHeader);FSRead_(appref,&count,appPEF.loaderRelocationHeader);#ifdef __INTEL__Swap_PEFLoaderRelocationHeader(appPEF.loaderRelocationHeader);#endifSetFPos_(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset);SetFPos_(appref,fsFromMark,appPEF.loaderInfoHeader.relocInstrOffset);relocSection = (unsigned short*)NewPtr((appPEF.loaderRelocationHeader->relocCount)*2);count = (appPEF.loaderRelocationHeader->relocCount)*2;FSRead_(appref,&count,relocSection);#ifdef __INTEL__for(i=0;i<(appPEF.loaderRelocationHeader->relocCount);i++){Swap_SHORT(&(relocSection[i]));}#endif//---------------Read In Relocations---------------needsExpansion = true;//---------------Read In Data Section---------------for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFPackedDataSection){foundSection=true;break;}}if(foundSection){dataSelector = i;SetFPos_(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset);count = appPEF.sectionHeader[i].containerLength;dataSectionC = NewPtr(count);dataSectionE = nil;FSRead_(appref,&count,dataSectionC);}else{for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFUnpackedDataSection){foundSection=true;break;}}if(foundSection){needsExpansion = false;dataSelector = i;SetFPos_(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset);count = appPEF.sectionHeader[i].containerLength;dataSectionE = NewPtr(count);dataSectionC = nil;FSRead_(appref,&count,dataSectionE);}else{DebugFunction(gNoDataSection);}}//---------------Read In Data Section---------------if(needsExpansion){		MyPStrAdd(appName,"\p.data",appNameWExt);	FileRef_To_FileRef_NewName(placeHolder,appNameWExt,dataSectionFile);	FSpCreate(dataSectionFile,'Doug','RSRC',smSystemScript);	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	totalWritten=0;						//---------------Expand Data Section---------------	//dataSectionE = NewPtr(appPEF.sectionHeader[dataSelector].totalLength);	dataSectionE = NewPtr(BUFF_SIZE);	if(!dataSectionE){DebugFunction("\pMemory Allocation Error");}	bm = 0;zzz=0;	k = appPEF.sectionHeader[dataSelector].containerLength;	dataCM=0;	dataEM=0;	for(;dataCM<k;)	{	#ifdef __POWERPC__	zzz++;if(!(zzz%1000)){IdleControls(GetFrontWindowOfClass(kAllWindowClasses,0));ReceiveNextEvent(0,NULL,kEventWaitTime,false,NULL);}	GetKeys(keyMap);	if(keyMap[1] == 0x00808000){gAborted=true;goto abort;}	#endif	switch((dataSectionC[dataCM]&0xE0)>>5)	{	case 0:			//Zero	{	if(dataSectionC[dataCM]&0x1F)	{	count = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(count)	}	for(i=0;i<count;i++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	break;	}	case 1:			//blockCopy	{	if(dataSectionC[dataCM]&0x1F)	{	blockSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(blockSize)	}	for(i=0;i<blockSize;i++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	break;	}	case 2:			//repeatedBlock	{	if(dataSectionC[dataCM]&0x1F)	{	blockSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(blockSize)	}	_ExtractArgument(repeatCount)	repeatCount++;//stored value is one less than actual	dataCMHolder = dataCM;	for(m=0;m<repeatCount;m++)	{	dataCM = dataCMHolder;	for(n=0;n<blockSize;n++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	}	break;	}	case 3:			//interleaveRepeatBlockWithBlockCopy	{	if(dataSectionC[dataCM]&0x1F)	{	commonSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(commonSize)	}	_ExtractArgument(customSize)	_ExtractArgument(repeatCount)	commonData = NewPtr(commonSize);	for(i=0;i<commonSize;i++)	{	commonData[i] = dataSectionC[dataCM];	dataCM++;	}	for(m=0;m<repeatCount;m++)	{	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = commonData[n];	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	for(n=0;n<customSize;n++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	}	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = commonData[n];	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	DisposePtr(commonData);	break;	}	case 4:			//interleaveRepeatBlockWithZero	{	if(dataSectionC[dataCM]&0x1F)	{	commonSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(commonSize)	}	_ExtractArgument(customSize)	_ExtractArgument(repeatCount)	for(m=0;m<repeatCount;m++)	{	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	for(n=0;n<customSize;n++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	}	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	break;	}	default: DebugFunction(gBadDataOpcode);break;	}	}	//if(appPEF.sectionHeader[dataSelector].unpackedLength != dataEM){DebugFunction(gBadDataOpcode);}	for(i=0;i<(appPEF.sectionHeader[dataSelector].totalLength-appPEF.sectionHeader[dataSelector].unpackedLength);i++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	//---------------Expand Data Section---------------	//---------------Write Out Expanded Data Section---------------	count=dataEM;	FSWrite(outFRef,&count,dataSectionE);	totalWritten+=count;	SetEOF(outFRef,totalWritten);	FSClose(outFRef);	//---------------Write Out Expanded Data Section---------------}else{	MyPStrAdd(appName,"\p.data",appNameWExt);	FileRef_To_FileRef_NewName(placeHolder,appNameWExt,dataSectionFile);	FSpCreate(dataSectionFile,'Doug','RSRC',smSystemScript);	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	totalWritten=0;		count=appPEF.sectionHeader[dataSelector].totalLength;	FSWrite(outFRef,&count,dataSectionE);	totalWritten+=count;	SetEOF(outFRef,totalWritten);	FSClose(outFRef);}//---------------Write Out Relocation Instructions---------------MyPStrAdd(appName,"\p.reloc",appNameWExt);FileRef_To_FileRef_NewName(placeHolder,appNameWExt,relocSectionFile);FSpCreate(relocSectionFile,'CWIE','TEXT',smSystemScript);FSpOpenDF(relocSectionFile,fsRdWrPerm,&outFRef);totalWritten=0;rowPB.outFRef		= outFRef;rowPB.totalWritten 	= &totalWritten;rowPB.relocSize 	= (appPEF.loaderRelocationHeader->relocCount);rowPB.relocInst 	= relocSection;rowPB.section 		= appPEF.loaderRelocationHeader->sectionIndex;rowPB.pos			= 0;RelocationOpcodeWriter(&rowPB);if(gAborted){goto abort;}SetEOF(outFRef,totalWritten);FSClose(outFRef);//---------------Write Out Relocation Instructions---------------/*//---------------Write Out Section Offsets---------------MyPStrAdd(appFSSpecPtr->name,"\p.secoff",pString);MyPStrAdd("\p:",pString,resFName);MyPStrAdd(dissFolder->name,resFName,pString);MyPStrAdd("\p:",pString,resFName);FSMakeFSSpec(dissFolder->vRefNum,dissFolder->parID,resFName,outFile);FSpCreate(outFile,'Doug','RSRC',smSystemScript);FSpOpenDF(outFile,fsRdWrPerm,&outFRef);totalWritten=0;count = 4;FSWrite(outFRef,&count,&appPEF.loaderInfoHeader.mainOffset);totalWritten+=count;FSWrite(outFRef,&count,&appPEF.loaderInfoHeader.initOffset);totalWritten+=count;FSWrite(outFRef,&count,&appPEF.loaderInfoHeader.termOffset);totalWritten+=count;SetEOF(outFRef,totalWritten);FSClose(outFRef);//---------------Write Out Section Offsets---------------*/#ifdef __POWERPC__//---------------Copy Resource Fork---------------MyPStrAdd(appName,"\p.rsrc",appNameWExt);FileRef_To_FileRef_NewName(placeHolder,appNameWExt,resourceSectionFile);FSpCreateResFile((FSSpec*)resourceSectionFile,'Doug','RSRC',smSystemScript);CopyResources((FileReference)fref,resourceSectionFile);//---------------Copy Resource Fork---------------#endif//---------------Read In Code Section---------------SetFPos_(appref,fsFromStart,appPEF.sectionHeader[codeSelector].containerOffset);count = appPEF.sectionHeader[codeSelector].containerLength;codeSection = (long*)NewPtr(count);FSRead_(appref,&count,codeSection);#ifdef __INTEL__for(i=0;i<appPEF.sectionHeader[codeSelector].containerLength/4;i++){Swap_LONG(&(codeSection[i]));}#endif//---------------Read In Code Section---------------fragPoint.m=false;fragPoint.i=false;fragPoint.t=false;if(appPEF.loaderInfoHeader.mainSection>=0){	if(appPEF.loaderInfoHeader.mainSection!=dataSelector){DebugFunction(gGenericError);}	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	SetFPos(outFRef,fsFromStart,appPEF.loaderInfoHeader.mainOffset);	GetFPos(outFRef,&temp);	count = sizeof(long);	FSRead(outFRef,&count,&temp);	FSClose(outFRef);	//temp = (long*)&dataSectionE[appPEF.loaderInfoHeader.mainOffset];	#ifdef __INTEL__	Swap_LONG(&temp);	#endif	fragPoint.main = temp;	fragPoint.m=true;}if(appPEF.loaderInfoHeader.initSection>=0){	if(appPEF.loaderInfoHeader.initSection!=dataSelector){DebugFunction(gGenericError);}	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	SetFPos(outFRef,fsFromStart,appPEF.loaderInfoHeader.initOffset);	count = sizeof(long);	FSRead(outFRef,&count,&temp);	FSClose(outFRef);	//temp = (long*)&dataSectionE[appPEF.loaderInfoHeader.initOffset];	#ifdef __INTEL__	Swap_LONG(&temp);	#endif	fragPoint.init = temp;	fragPoint.i=true;}if(appPEF.loaderInfoHeader.termSection>=0){	if(appPEF.loaderInfoHeader.termSection!=dataSelector){DebugFunction(gGenericError);}		FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	SetFPos(outFRef,fsFromStart,appPEF.loaderInfoHeader.termOffset);	count = sizeof(long);	FSRead(outFRef,&count,&temp);	FSClose(outFRef);		//temp = (long*)&dataSectionE[appPEF.loaderInfoHeader.termOffset];	#ifdef __INTEL__	Swap_LONG(&temp);	#endif	fragPoint.term = temp;	fragPoint.t=true;}MyPStrAdd(appName,"\p.asm",appNameWExt);FileRef_To_FileRef_NewName(placeHolder,appNameWExt,codeSectionFile);FSpCreate(codeSectionFile,'CWIE','TEXT',smSystemScript);FSpOpenDF(codeSectionFile,fsRdWrPerm,&outFRef);totalWritten=0;llPB.codeLength		=	appPEF.sectionHeader[codeSelector].containerLength;llPB.codeSection	=	codeSection;llPB.fragPoint		=	fragPoint;llPB.codeExport		=	expCode;llPB.libcount		=	appPEF.loaderInfoHeader.importedLibraryCount;llPB.lib			=	impLib;llPB.sym			=	impSym;llPB.name			=	loaderNameTable;rowPB.llpb = &llPB;RelocationVM(&rowPB);llPB.rm				=	&rowPB.rMachine;mwPB.codeLength		= appPEF.sectionHeader[codeSelector].containerLength;mwPB.codeSection	= codeSection;mwPB.totalWritten	= &totalWritten;mwPB.outFRef		= outFRef;#ifdef __POWERPC__mwPB.progBar		= gAppControls.progressBar;#endif#ifdef __INTEL__mwPB.progBar		= winProgBar;#endifmwPB.labelList		= MakeLabelList(&llPB);if(gAborted){goto abort;}mwPB.rm = &rowPB.rMachine;#ifdef __INTEL__SetWindowText(statText, "Writing Mnemonics...");#endifMnemonicWriter(&mwPB);if(gAborted){goto abort;}#ifdef __INTEL__DestroyWindow(winProgBar);DestroyWindow(statText);#endifImportWriter(appPEF.loaderInfoHeader.importedLibraryCount,impLib,impSym,loaderNameTable,&totalWritten,outFRef);SetEOF(outFRef,totalWritten);FSClose(outFRef);#ifdef __POWERPC__FSpMakeFSRef((FSSpec*)fref,&newRef);FSGetCatalogInfo(&newRef,kFSCatInfoFinderInfo,&catInfo,0,0,0);//keyfilePB.finderInfo	= catInfo.finderInfo;#endifkeyfilePB.dissFolder	= (FileReference)destRef;#ifdef __POWERPC__keyfilePB.appName		= (Str255*)(&((FSSpec*)fref)->name);#endif#ifdef __INTEL__for(i=0;((char*)fref)[i]!=0;i++){}j=i;for(;((char*)fref)[i]!='\\';i--){}i++;j=j-i;keyfilePB.appName = (Str255*)NewPtr(j+1);for(k=0;k<j;k++){((char*)keyfilePB.appName)[k+1] = ((char*)fref)[i+k];}((char*)keyfilePB.appName)[0]=j;#endifkeyfilePB.dataExports	= expData;keyfilePB.mainOffset	= appPEF.loaderInfoHeader.mainOffset;keyfilePB.initOffset	= appPEF.loaderInfoHeader.initOffset;keyfilePB.termOffset	= appPEF.loaderInfoHeader.termOffset;keyfilePB.mach			= false;WriteKeyFile(&keyfilePB);#ifdef __INTEL__DisposePtr((char*)keyfilePB.appName);#endifwhile(expData){currEDd = expData->next;DisposePtr(expData->label);DisposePtr((char*)expData);expData = currEDd;}while(expCode){currCDd = expCode->next;DisposePtr(expCode->label);DisposePtr((char*)expCode);expCode = currCDd;}abort:;#ifdef __POWERPC__if(dataSectionFile){DisposePtr((char*)dataSectionFile);}if(relocSectionFile){DisposePtr((char*)relocSectionFile);}if(codeSectionFile){DisposePtr((char*)codeSectionFile);}if(resourceSectionFile){DisposePtr((char*)resourceSectionFile);}#endifDisposePtr((char*)appPEF.sectionHeader);DisposePtr((char*)impLib);DisposePtr((char*)impSym);DisposePtr((char*)loaderNameTable);DisposePtr((char*)appPEF.loaderRelocationHeader);DisposePtr((char*)relocSection);if(dataSectionC){DisposePtr((char*)dataSectionC);}if(dataSectionE){DisposePtr((char*)dataSectionE);}DisposePtr((char*)codeSection);if(!gAborted){thenow = rowPB.rMachine.sym;while(thenow){forbye = thenow;thenow = thenow->next;DisposePtr(forbye->label);DisposePtr((char*)forbye);}}else{thenow = rowPB.rMachine.sym;while(thenow && IsPointerValid((char*)thenow)){forbye = thenow;thenow = thenow->next;if(IsPointerValid(forbye->label)){DisposePtr(forbye->label);}if(IsPointerValid((char*)forbye)){DisposePtr((char*)forbye);}}}#ifdef __POWERPC__TransitionWindow(gAppWindow,kWindowZoomTransitionEffect,kWindowHideTransitionAction,NULL);#endifgAborted=false;}