Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"void FileRef_GetFileName(void *src,unsigned char *dest){long	i,j;#ifdef __POWERPC__MyPStrAdd(((FSSpec*)src)->name,"\p",dest);#endif#ifdef __INTEL__for(i=0;((char*)src)[i]!=0;i++){}for(;((char*)src)[i]!='\\';i--){}i++;for(j=1;((char*)src)[i]!=0;i++,j++){dest[j]=((char*)src)[i];}dest[0]=j-1;#endif}void FileRef_To_FileRef_NewName(void *src,unsigned char *fname,void *dest){long	i,j;#ifdef __POWERPC__FSMakeFSSpec(((FSSpec*)src)->vRefNum,((FSSpec*)src)->parID,fname,(FSSpec*)dest);#endif#ifdef __INTEL__for(i=0;((char*)src)[i]!=0;i++){((char*)dest)[i]=((char*)src)[i];}for(;((char*)src)[i]!='\\';i--){}i++;for(j=0;j<fname[0];j++,i++){((char*)dest)[i]=fname[j+1];}((char*)dest)[i]=0;#endif}void FileRef_To_FileRef_Copy(void *src, void *dest){long	i;#ifdef __POWERPC__FSMakeFSSpec(((FSSpec*)src)->vRefNum,((FSSpec*)src)->parID,((FSSpec*)src)->name,(FSSpec*)dest);#endif#ifdef __INTEL__for(i=0;((char*)src)[i]!=0;i++){((char*)dest)[i]=((char*)src)[i];}((char*)dest)[i]=0;#endif}FileReference FileRef_Allocate(void){#ifdef __POWERPC__return (FileReference)NewPtr(sizeof(FSSpec));#endif#ifdef __INTEL__return (FileReference)NewPtr(MAX_PATH);#endif}void FileRef_Dispose(FileReference ref){DisposePtr((char*)ref);}void FileRef_To_FileRef_InDirectory(void *src,unsigned char *fname,void *dest){long i,j,k;Str255 pString,pString2;#ifdef __POWERPC__MyPStrAdd("\p:",fname,pString2);if(((FSSpec*)src)->name[0]){MyPStrAdd(((FSSpec*)src)->name,pString2,pString);MyPStrAdd("\p:",pString,pString2);}FSMakeFSSpec(((FSSpec*)src)->vRefNum,((FSSpec*)src)->parID,pString2,(FSSpec*)dest);#endif#ifdef __INTEL__i=0;while(((char*)src)[i]!=0){((char*)dest)[i]=((char*)src)[i];i++;}((char*)dest)[i]='\\';i++;for(k=0;k<fname[0];k++,i++){((char*)dest)[i] = fname[k+1];}((char*)dest)[i]=0;#endif}long FileRef_GetNameLength(FileReference file){long	i,j;#ifdef __POWERPC__return ((FSSpec*)file)->name[0];#endif#ifdef __INTEL__for(i=0;((char*)file)[i]!=0;i++){}for(;((char*)file)[i]!='\\';i--){}i++;for(j=0;((char*)file)[i]!=0;i++,j++){}return j;#endif}void FileRef_NewInAppDir(unsigned char* name,FileReference dest){long i;#ifdef __POWERPC__FSMakeFSSpec(0,0,name,(FSSpec*)dest);#endif#ifdef __INTEL__for(i=0;i<name[0];i++){((char*)dest)[i] = name[i+1];}((char*)dest)[i]=0;#endif}long CheckError_FSpOpenDF(void* error){long err;#ifdef __POWERPC__return (long)error;#endif#ifdef __INTEL__if(error==INVALID_HANDLE_VALUE){err = GetLastError();if(err==ERROR_FILE_NOT_FOUND){return fnfErr;}else{return 1;}}else{return 0;}#endif}