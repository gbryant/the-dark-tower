Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define POWERPC_NAME_APPEND(X,Y)  																	\																									\MyPStrAdd(((FSSpec*)fref)->name,X,tempPStr1);														\MyPStrAdd("\p:",tempPStr1,tempPStr2);																\MyPStrAdd(((FSSpec*)destRef)->name,tempPStr2,tempPStr1);											\MyPStrAdd("\p:",tempPStr1,tempPStr2);																\FSMakeFSSpec(((FSSpec*)destRef)->vRefNum,((FSSpec*)destRef)->parID,tempPStr2,Y);#define	INTEL_NAME_APPEND(X,Y)												\																			\ZeroMemory(&Y,MAX_PATH);													\i=0;																		\while(((char*)destRef)[i]!=0){Y[i] = ((char*)destRef)[i];i++;}				\Y[i]=0;																		\i=0;while(((char*)fref)[i]!=0){i++;}										\while(((char*)fref)[i]!='\\'){i--;}a=i+1;									\i=0;while(((char*)Y)[i]!=0){i++;}((char*)Y)[i]='\\';i++;					\while(((char*)fref)[a]!=0){((char*)Y)[i] = ((char*)fref)[a];i++;a++;}		\for(a=0;a<(sizeof(X)-1);a++,i++){((char*)Y)[i]=X[a];}						\((char*)Y)[i]=0;#define WRITE_STRING(X)					\count=sizeof(X)-1;						\FSWrite(outInfoRef,&count,X);			\totalWritten2+=count;#define WRITE_TAB(X)								\for(z=0;z<X;z++)									\{													\count = 1;											\FSWrite(outInfoRef,&count,"\t");					\totalWritten2 += count;								\}#define	_WRITE_(X,Y)			\							\for(k=0;k<X;k++)			\{							\buffer[bm] = Y[k];bm++;		\}#define	_WRITE_STRING(X)			\							\for(k=0;k<(sizeof(X)-1);k++)			\{							\buffer[bm] = X[k];bm++;		\}#define WRITE(X,Y)							\											\count=X;									\FSWrite(outInfoRef,&count,Y);				\totalWritten2+=count;void DisassemblePE(void	*fref, void	*destRef){char *buffer;long bm;long					totalWritten2,totalWritten;long					i,j,k,a,currSect,codeLoop;unsigned long			count;IMAGE_DOS_HEADER 		header;IMAGE_NT_HEADERS 		peHeader;IMAGE_SECTION_HEADER	*sectionHeaders;void					*appref;Str255					tempPStr1,tempPStr2;void					*outInfoRef,*asmOutRef;char					number[256];MnemonicWriterPBlock	mwPB;unsigned char			*insts;Boolean					boolVal;KeyFilePB						keyfilePB;long					inPos,totalData,tabcount,z;#ifdef __POWERPC__FSSpec					*infoFile,*asmFile;#endif#ifdef __INTEL__char					infoFile[MAX_PATH];char					asmFile[MAX_PATH];long					cyVScroll;HWND					winProgBar,statText;RECT					winRect;#endifchar					*inData;Str255							appName;#ifdef __POWERPC__infoFile = (FSSpec*)NewPtr(sizeof(FSSpec));asmFile = (FSSpec*)NewPtr(sizeof(FSSpec));MyPStrAdd(((FSSpec*)fref)->name,"\p.info",tempPStr1);MyPStrAdd("\p:",tempPStr1,tempPStr2);MyPStrAdd(((FSSpec*)destRef)->name,tempPStr2,tempPStr1);MyPStrAdd("\p:",tempPStr1,tempPStr2);FSMakeFSSpec(((FSSpec*)destRef)->vRefNum,((FSSpec*)destRef)->parID,tempPStr2,infoFile);#endif#ifdef __INTEL__INTEL_NAME_APPEND(".info",infoFile)#endifFSpCreate(infoFile,'CWIE','TEXT',smSystemScript);FSpOpenDF(infoFile,fsRdWrPerm,&outInfoRef);totalWritten2=0;FSpOpenDF(fref,fsRdPerm,&appref);SetFPos(appref,fsFromStart,0);count = sizeof(IMAGE_DOS_HEADER);FSRead(appref,&count,&header);#ifdef __POWERPC__Swap_IMAGE_DOS_HEADER(&header);#endifSetFPos(appref,fsFromStart,header.e_lfanew);count = sizeof(IMAGE_NT_HEADERS);FSRead(appref,&count,&peHeader);#ifdef __POWERPC__Swap_IMAGE_NT_HEADERS(&peHeader);#endifsectionHeaders = (IMAGE_SECTION_HEADER*)NewPtr(sizeof(IMAGE_SECTION_HEADER)*peHeader.FileHeader.NumberOfSections);count = (sizeof(IMAGE_SECTION_HEADER)*peHeader.FileHeader.NumberOfSections);FSRead(appref,&count,sectionHeaders);if(peHeader.FileHeader.Machine==IMAGE_FILE_MACHINE_I386){	#ifdef __POWERPC__	for(i=0;i<peHeader.FileHeader.NumberOfSections;i++)	{Swap_IMAGE_SECTION_HEADER(&sectionHeaders[i]);}	for(i=0;i<IMAGE_NUMBEROF_DIRECTORY_ENTRIES;i++)	{Swap_IMAGE_DATA_DIRECTORY(&peHeader.OptionalHeader.DataDirectory[i]);}	#endif		//NumberToString(peHeader.FileHeader.NumberOfSections,number);	//WRITE_STRING("NumberOfSections: ")	//_WRITE(number[0],number+1)		for(currSect=0;currSect<peHeader.FileHeader.NumberOfSections;currSect++)	{		WRITE_STRING("Section: ")		NumberToString(currSect+1,number);		WRITE(number[0],number+1)		WRITE_STRING("\r{\r")				WRITE_STRING("Name:\t\t\t\t")		for(k=0;sectionHeaders[currSect].Name[k]!=0 && k<=8;k++){}		WRITE(k,sectionHeaders[currSect].Name)		WRITE_STRING("\r")						WRITE_STRING("VirtualAddress:\t\t0x")		hex2char(sectionHeaders[currSect].VirtualAddress,number);		k=0;while(number[k]=='0'&&k<7){k++;}		WRITE(8-k,number+k)		WRITE_STRING("\r")				WRITE_STRING("SizeOfRawData:\t\t0x")		hex2char(sectionHeaders[currSect].SizeOfRawData,number);		k=0;while(number[k]=='0'&&k<7){k++;}		WRITE(8-k,number+k)		WRITE_STRING("\r")						WRITE_STRING("PointerToRawData:\t0x")		hex2char(sectionHeaders[currSect].PointerToRawData,number);		k=0;while(number[k]=='0'&&k<7){k++;}		WRITE(8-k,number+k)		WRITE_STRING("\r")								WRITE_STRING("Characteristics:\t0x")				hex2char(sectionHeaders[currSect].Characteristics,number);				WRITE(8,number)		WRITE_STRING("\r}\r")						if(sectionHeaders[currSect].Characteristics&IMAGE_SCN_CNT_CODE)		{			//WRITE_STRING("IMAGE_SCN_CNT_CODE\r");			SetFPos(appref,fsFromStart,sectionHeaders[currSect].PointerToRawData);			count = sectionHeaders[currSect].SizeOfRawData;			insts = (unsigned char*)NewPtr(count);			FSRead(appref,&count,insts);									DT_SetProgressState(gAppControls.progressBar,kControlProgressBarIndeterminateTag,false);			#ifdef __POWERPC__			SetControl32BitMaximum(gAppControls.progressBar,sectionHeaders[currSect].SizeOfRawData/1000);			#endif						#ifdef __INTEL__cyVScroll = GetSystemMetrics(SM_CYHSCROLL);InitCommonControls();GetClientRect(gHwnd,&winRect);winProgBar = CreateWindowEx(0,PROGRESS_CLASS,0,WS_CHILD|WS_VISIBLE,winRect.left,winRect.bottom-cyVScroll,winRect.right,cyVScroll,gHwnd,(HMENU)0,(HINSTANCE)0,0);statText = CreateWindowEx(0,"Static",0,WS_CHILD|WS_VISIBLE|SS_CENTER,winRect.left,winRect.bottom-winRect.bottom/2,winRect.right,50,gHwnd,(HMENU)0,(HINSTANCE)0,0);SendMessage(winProgBar,PBM_SETRANGE32,0,sectionHeaders[currSect].SizeOfRawData/1000);SendMessage(winProgBar,PBM_SETSTEP,1,0);//SendMessage(winProgBar,PBM_STEPIT,0,0);#endif																											FileRef_GetFileName(fref,appName);						keyfilePB.dissFolder	= (FileReference)destRef;			keyfilePB.appName		= &appName;			keyfilePB.dataExports	= 0;			keyfilePB.fileType		= 'DEXE';			keyfilePB.fileCreator	= 'CWIE';			keyfilePB.mach			= false;			keyfilePB.intel			= true;			keyfilePB.cfrg			= false;			WriteKeyFile(&keyfilePB);																																																#ifdef __POWERPC__			POWERPC_NAME_APPEND("\p.asm",asmFile)			#endif			#ifdef __INTEL__			INTEL_NAME_APPEND(".asm",asmFile)			#endif			FSpCreate(asmFile,'CWIE','TEXT',smSystemScript);			FSpOpenDF(asmFile,fsRdWrPerm,&asmOutRef);			totalWritten=0;						mwPB.codeLength		= sectionHeaders[currSect].SizeOfRawData;			mwPB.codeSection2	= insts;			mwPB.totalWritten	= &totalWritten;			mwPB.outFRef		= asmOutRef;			#ifdef __POWERPC__			mwPB.progBar		= gAppControls.progressBar;			#endif			#ifdef __INTEL__			mwPB.progBar		= winProgBar;			#endif			mwPB.labelList		= 0;						#ifdef __INTEL__			SetWindowText(statText, "Writing Mnemonics...");			#endif						MnemonicWriter386(&mwPB);									SetEOF(asmOutRef,totalWritten);			FSClose(asmOutRef);						#ifdef __INTEL__			DestroyWindow(winProgBar);			DestroyWindow(statText);			#endif		}		WRITE_STRING("\r")	}	}FSClose(appref);SetEOF(outInfoRef,totalWritten2);inData = NewPtr(totalWritten2);count = totalWritten2;SetFPos(outInfoRef,fsFromStart,0);FSRead(outInfoRef,&count,inData);SetFPos(outInfoRef,fsFromStart,0);totalData=totalWritten2;inPos=0;tabcount=0;totalWritten2=0;i=0;while(inPos<totalData){	while(inData[i]!='\r'){i++;}	if(inData[i-1]=='{'){tabcount++;}	else if(inData[i+1]=='}'){tabcount--;}	count = i-inPos+1;	FSWrite(outInfoRef,&count,inData+inPos);	totalWritten2 += count;	i++;	inPos=i;	WRITE_TAB(tabcount);		}SetEOF(outInfoRef,totalWritten2);FSClose(outInfoRef);FSClose(outInfoRef);WriteStatus("Idle");DT_SetProgressState(gAppControls.progressBar,kControlProgressBarIndeterminateTag,false);SetControl32BitValue(gAppControls.progressBar,0);#ifdef __POWERPC__DisposePtr((char*)asmFile);DisposePtr((char*)infoFile);#endif}