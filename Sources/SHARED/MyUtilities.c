Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define UL unsigned longlong _pow(long a, long b){long	i,returnval;for(i=0,returnval=1;i<b;i++){returnval*=a;}return returnval;}/*unsigned short myShortRangedRandom(unsigned short min,unsigned short max){register unsigned short		qdRdm;		//treat return value as 0-65536register unsigned long		range,t;qdRdm =(unsigned short) Random();range =max-min;if (range != 1) t = (qdRdm * range) >> 16;		//now 0 <= t <= rangeelse		    t = (qdRdm % 2);return (t+min);}*/short CountBits(long value){long	i;short	bitCount;for(bitCount=0,i=31;i>=0;i--){if(value & (1<<i)){bitCount=i;bitCount++;goto end;}}end:return bitCount;}long BitsToNumber(long bits){long	number,i;number = 0;i = bits;i--;for(;i>=0;i--){number += 1<<i;}return number;}long StringLength(char* string){long length;length=0;while(string[length]!=0){length++;}return length;}void NumberToString(long number, char *string){long i,j,k;unsigned char a;Boolean neg=false;if(number<0){neg=true;number*=-1;}if((UL)number!=0){	i=1;	while((UL)number!=0)	{	string[i] = ((UL)number % 10) + 0x30;	number /= 10;	i++;	}	string[0]=i-1;	j = string[0];	for(i=1;i<=string[0]/2;i++,j--)	{	a = string[i];	string[i] = string[j];	string[j] = a;	}if(neg){for(i=string[0]+1;i>=0;i--){string[i+1]=string[i];}string[0]+=1;string[1]='-';}}else{string[0]=1;string[1]='0';}}/*void CopyCStringToPascal( const char* source, Str255 dest ){	SInt16 	length  = 0;		// handle case of overlapping strings	if( (void*) source == (void*) dest)	{		unsigned char*		curdst = &dest[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*) source++;		while (thisChar != '\0') 		{			unsigned char nextChar;						// use nextChar so we don't overwrite what we are about to read			nextChar = *(const unsigned char*) source++;			*curdst++ = thisChar;			thisChar = nextChar;						if (++length >= 255)				break;		}	}	else if (source != NULL)	{		unsigned char*		curdst = &dest[1];		SInt16 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can't do the K&R C thing of Òwhile (*s++ = *t++)Ó because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while( (temp = *source++) != 0 ) 		{			*(char*) curdst++ = temp;							if (--overflow <= 0)				break;		}		length = 255 - overflow;	}	dest[0] = length;}*/