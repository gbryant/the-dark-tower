Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define	WRITE_(X,Y)							\											\rowPB->count = X;							\FSWrite(rowPB->outFRef,&rowPB->count,Y);	\(*rowPB->totalWritten)+=rowPB->count;#define write_RETURN						\											\rowPB->count = 1;							\FSWrite(rowPB->outFRef,&rowPB->count,"\r");	\(*rowPB->totalWritten)+=rowPB->count;#define write_TAB							\											\rowPB->count = 1;							\FSWrite(rowPB->outFRef,&rowPB->count,"\t");	\(*rowPB->totalWritten)+=rowPB->count;#define write_COMMA							\											\rowPB->count = 1;							\FSWrite(rowPB->outFRef,&rowPB->count,",");	\(*rowPB->totalWritten)+=rowPB->count;void RelocationOpcodeWriter(RelocOpWriterPBlock *rowPB){long a;long zzz;KeyMap					keyMap;rowPB->rMachine.relocAddress=0;rowPB->rMachine.importIndex=0;rowPB->rMachine.sectionC=0;rowPB->rMachine.sectionD=0;zzz=0;while(rowPB->pos < rowPB->relocSize){#ifdef __POWERPC__zzz++;if(!(zzz%1000)){IdleControls(GetFrontWindowOfClass(kAllWindowClasses,0));ReceiveNextEvent(0,NULL,kEventWaitTime,false,NULL);}GetKeys(keyMap);if(keyMap[1] == 0x00808000){gAborted=true;goto abort;}#endif//relocOpCode[(rowPB->relocInst[rowPB->pos]&0xFE00)>>9](rowPB);switch((rowPB->relocInst[rowPB->pos]&0xFE00)>>9){	case 0x00:	case 0x01:	case 0x02:	case 0x03:	case 0x04:	case 0x05:	case 0x06:	case 0x07:	case 0x08:	case 0x09:	case 0x0A:	case 0x0B:	case 0x0C:	case 0x0D:	case 0x0E:	case 0x0F:	case 0x10:	case 0x11:	case 0x12:	case 0x13:	case 0x14:	case 0x15:	case 0x16:	case 0x17:	case 0x18:	case 0x19:	case 0x1A:	case 0x1B:	case 0x1C:	case 0x1D:	case 0x1E:	case 0x1F:	{	rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x3FC0)>>6)*4);	rowPB->rMachine.relocAddress += ((rowPB->relocInst[rowPB->pos]&0x3F)*4);	WRITE_(4,"DDAT")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x3FC0)>>6,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_COMMA	NumToString((rowPB->relocInst[rowPB->pos]&0x3F),gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x20:	{	rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*4);	WRITE_(4,"CODE")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x21:	{	rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*4);	WRITE_(4,"DATA")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x22:	{	rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*12);	WRITE_(4,"DESC")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x23:	{	rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*8);	WRITE_(4,"DSC2")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x24:	{	rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*8);	WRITE_(4,"VTBL")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x25:	{	WRITE_(4,"SYMR")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x30:	{	WRITE_(4,"SYMB")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x31:	{	WRITE_(4,"CDIS")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x32:	{	WRITE_(4,"DTIS")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x33:	{	rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*4);	WRITE_(4,"SECN")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x40:	case 0x41:	case 0x42:	case 0x43:	case 0x44:	case 0x45:	case 0x46:	case 0x47:	{	rowPB->rMachine.relocAddress += ((rowPB->relocInst[rowPB->pos]&0xFFF)+1);	WRITE_(4,"DELT")	write_TAB	NumToString((rowPB->relocInst[rowPB->pos]&0xFFF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x48:	case 0x49:	case 0x4A:	case 0x4B:	case 0x4C:	case 0x4D:	case 0x4E:	case 0x4F:	{	WRITE_(3,"RPT")	write_TAB;write_TAB	NumToString(((rowPB->relocInst[rowPB->pos]&0xF00)>>8)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_COMMA	NumToString((rowPB->relocInst[rowPB->pos]&0xFF)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=1;	break;	}		case 0x50:	case 0x51:	{	WRITE_(4,"LABS")	write_TAB	#ifdef __INTEL__	a = (rowPB->relocInst[rowPB->pos]);	(rowPB->relocInst[rowPB->pos]) = (rowPB->relocInst[rowPB->pos+1]);	(rowPB->relocInst[rowPB->pos+1]) = a;	#endif	NumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03FFFFFF,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	#ifdef __INTEL__	a = (rowPB->relocInst[rowPB->pos]);	(rowPB->relocInst[rowPB->pos]) = (rowPB->relocInst[rowPB->pos+1]);	(rowPB->relocInst[rowPB->pos+1]) = a;	#endif	rowPB->pos+=2;	break;	}		case 0x52:	case 0x53:	{	WRITE_(4,"LSYM")	write_TAB	NumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03FFFFFF,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=2;	break;	}		case 0x58:	case 0x59:	{	WRITE_(4,"LRPT")	write_TAB	NumToString((((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03C00000)>>22)+1,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_COMMA	NumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x003FFFFF,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=2;	break;	}		case 0x5A:	{	WRITE_(4,"LSEC")	write_TAB	NumToString(((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03C00000)>>22,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_COMMA	NumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x003FFFFF,gtempstr);	WRITE_(gtempstr[0],gtempstr+1);	write_RETURN	rowPB->pos+=2;	break;	}		default:DebugFunction("\pAn illegal relocation instruction was found");break;}}abort:;}/*void IllegalROP(RelocOpWriterPBlock *rowPB){DebugFunction(gIllegalByte);}void ROP_DDAT(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x3FC0)>>6)*4);rowPB->rMachine.relocAddress += ((rowPB->relocInst[rowPB->pos]&0x3F)*4);WRITE_(4,"DDAT")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x3FC0)>>6,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_COMMANumToString((rowPB->relocInst[rowPB->pos]&0x3F),gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_CODE(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*4);WRITE_(4,"CODE")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_DATA(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*4);WRITE_(4,"DATA")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_DESC(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*12);WRITE_(4,"DESC")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_DSC2(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*8);WRITE_(4,"DSC2")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_VTBL(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*8);WRITE_(4,"VTBL")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_SYMR(RelocOpWriterPBlock *rowPB){WRITE_(4,"SYMR")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_SYMB(RelocOpWriterPBlock *rowPB){WRITE_(4,"SYMB")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_CDIS(RelocOpWriterPBlock *rowPB){WRITE_(4,"CDIS")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_DTIS(RelocOpWriterPBlock *rowPB){WRITE_(4,"DTIS")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_SECN(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += (((rowPB->relocInst[rowPB->pos]&0x1FF)+1)*4);WRITE_(4,"SECN")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0x1FF),gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_DELT(RelocOpWriterPBlock *rowPB){rowPB->rMachine.relocAddress += ((rowPB->relocInst[rowPB->pos]&0xFFF)+1);WRITE_(4,"DELT")write_TABNumToString((rowPB->relocInst[rowPB->pos]&0xFFF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_RPT(RelocOpWriterPBlock *rowPB){WRITE_(3,"RPT")write_TAB;write_TABNumToString(((rowPB->relocInst[rowPB->pos]&0xF00)>>8)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_COMMANumToString((rowPB->relocInst[rowPB->pos]&0xFF)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=1;}void ROP_LABS(RelocOpWriterPBlock *rowPB){WRITE_(4,"LABS")write_TABNumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03FFFFFF,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=2;}void ROP_LSYM(RelocOpWriterPBlock *rowPB){WRITE_(4,"LSYM")write_TABNumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03FFFFFF,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=2;}void ROP_LRPT(RelocOpWriterPBlock *rowPB){WRITE_(4,"LRPT")write_TABNumToString((((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03C00000)>>22)+1,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_COMMANumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x003FFFFF,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=2;}void ROP_LSEC(RelocOpWriterPBlock *rowPB){WRITE_(4,"LSEC")write_TABNumToString(((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x03C00000)>>22,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_COMMANumToString((*((long*)(&rowPB->relocInst[rowPB->pos])))&0x003FFFFF,gtempstr);WRITE_(gtempstr[0],gtempstr+1);write_RETURNrowPB->pos+=2;}*/