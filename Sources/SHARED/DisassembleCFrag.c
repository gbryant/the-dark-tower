Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define BUFF_SIZE 0x210000#define _ExtractArgument(X)						\X=0;											\while(dataSectionC[dataCM]&0x80)				\{												\X += dataSectionC[dataCM]&0x7F;					\X <<= 7;										\dataCM++;										\}												\X += dataSectionC[dataCM]&0x7F;					\dataCM++;void DisassembleCFrag(void	*fref, void	*destRef, MacBinaryIIIHeader *mbin3Header){PEFContainer					appPEF;RelocOpWriterPBlock				rowPB;short							resAttr;LabelListPBlock					llPB;MnemonicWriterPBlock			mwPB;MacBinaryIIIHeader 				mbin3HeaderRsrc;long							i,a,j,k,m,n,blockSize,commonSize,customSize,repeatCount,dataCM,dataEM,dataCMHolder;Boolean							foundSection,needsExpansion;Str255							tempPStr1,tempPStr2;long							totalWritten,bm;long							dataSelector,codeSelector,loaderSelector;Str255							resFName,resName;short							resCount;Handle							resHandle;short							resRefIn,resRefOut,typeCount;short							resID;long							dSizes;long							alignCount;char							*resFork;char							*dataSectionC=0;char							*dataSectionE=0,*buffer;unsigned short					*relocSection;char							*commonData;long							*codeSection;PEFImportedLibrary				*impLib;PEFImportedSymbol				*impSym;char							*loaderNameTable;PEFExportedSymbolHashSlot		*exSymHash;PEFExportedSymbolKey			*exSymKey;PEFExportedSymbol				*exSym;DataExport						*expData,**currExpData,*currEDd;CodeExport						*expCode,**currExpCode,*currCDd;void							*appref;void							*outFRef;LabelList						*thenow,*forbye;Rect							winBound;FragPoint						fragPoint;long							temp;Boolean							boolVal;Str255 							winTitle;KeyFilePB						keyfilePB;unsigned long					count;short 							resRef;FSRef 			        		newRef;KeyMap							keyMap;FSCatalogInfo 					catInfo;ResType							resType;//FSSpec						*outFile;FileReference					dataSectionFile;FileReference					relocSectionFile;FileReference					codeSectionFile;FileReference					resourceSectionFile;FileReference					placeHolder;Str255							appName,appNameWExt;long 							zzz;dataSectionFile = FileRef_Allocate();relocSectionFile = FileRef_Allocate();codeSectionFile = FileRef_Allocate();resourceSectionFile = FileRef_Allocate();if(mbin3Header){appName[0]=mbin3Header->fileNameLength;for(i=0;i<appName[0];i++){appName[i+1]=mbin3Header->fileName[i];}}else{FileRef_GetFileName(fref,appName);}placeHolder=FileRef_Allocate();FileRef_To_FileRef_InDirectory(destRef,appName,placeHolder);FSpOpenDF(fref,fsRdPerm,&appref);if(mbin3Header){SetFPos(appref,fsFromStart,sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,0);}count = sizeof(PEFContainerHeader);FSRead(appref,&count,&appPEF.containerHeader);#ifdef __INTEL__Swap_PEF_CONTAINER_HEADER(&appPEF.containerHeader);#endifcount = sizeof(PEFSectionHeader)*appPEF.containerHeader.sectionCount;appPEF.sectionHeader = (PEFSectionHeader*)NewPtr(count);FSRead(appref,&count,appPEF.sectionHeader);#ifdef __INTEL__for(i=0;i<appPEF.containerHeader.sectionCount;i++){Swap_PEF_SECTION_HEADER(&appPEF.sectionHeader[i]);}#endiffor(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFCodeSection){foundSection=true;break;}}if(foundSection){codeSelector = i;}else{for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFExecDataSection){foundSection=true;break;}}if(foundSection){codeSelector = i;}else{DebugFunction(gNoCodeSection);}}#ifdef __POWERPC__//boolVal=true;//SetControlData(gAppControls.progressBar,kControlEntireControl,kControlProgressBarIndeterminateTag,sizeof(Boolean),&boolVal);//TransitionWindow(gAppWindow,kWindowZoomTransitionEffect,kWindowShowTransitionAction,NULL);//DrawControls(gAppWindow);//ReceiveNextEvent(0,NULL,kEventWaitTime,false,NULL);#endif#ifdef __INTEL__//SendMessage(gAppControls.progressBar,PBM_SETRANGE32,0,((appPEF.sectionHeader[codeSelector].containerLength/4)/1000));//SendMessage(gAppControls.progressBar,PBM_SETSTEP,1,0);//ShowWindow(gAppControls.progressBar,SW_SHOW);//ShowWindow(gAppTopText,SW_SHOW);#endifDT_SetProgressState(gAppControls.progressBar,kControlProgressBarIndeterminateTag,true);WriteStatus("Gathering Data...");//---------------Read In Loader Info Header---------------for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFLoaderSection){foundSection=true;break;}}if(foundSection){loaderSelector = i;if(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset);}count = sizeof(PEFLoaderInfoHeader);FSRead(appref,&count,&appPEF.loaderInfoHeader);#ifdef __INTEL__Swap_PEF_LOADER_INFO_HEADER(&appPEF.loaderInfoHeader);#endif}else{DebugFunction(gNoLoaderSection);}//---------------Read In Loader Info Header---------------//---if(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset);}SetFPos(appref,fsFromMark,sizeof(PEFLoaderInfoHeader));impLib=(PEFImportedLibrary*)NewPtr(sizeof(PEFImportedLibrary)*appPEF.loaderInfoHeader.importedLibraryCount);impSym=(PEFImportedSymbol*)NewPtr(sizeof(PEFImportedSymbol)*appPEF.loaderInfoHeader.totalImportedSymbolCount);count = sizeof(PEFImportedLibrary)*appPEF.loaderInfoHeader.importedLibraryCount;FSRead(appref,&count,impLib);#ifdef __INTEL__for(i=0;i<appPEF.loaderInfoHeader.importedLibraryCount;i++)Swap_PEF_IMPORTED_LIBRARY(&impLib[i]);#endifcount = sizeof(PEFImportedSymbol)*appPEF.loaderInfoHeader.totalImportedSymbolCount;FSRead(appref,&count,impSym);#ifdef __INTEL__for(i=0;i<appPEF.loaderInfoHeader.totalImportedSymbolCount;i++)Swap_LONG(&impSym[i].classAndName);#endifloaderNameTable = NewPtr(appPEF.sectionHeader[loaderSelector].containerLength-appPEF.loaderInfoHeader.loaderStringsOffset);if(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+appPEF.loaderInfoHeader.loaderStringsOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+appPEF.loaderInfoHeader.loaderStringsOffset);}count = appPEF.sectionHeader[loaderSelector].containerLength - appPEF.loaderInfoHeader.loaderStringsOffset;FSRead(appref,&count,loaderNameTable);//Read in the export stuff hereexpCode=nil;expData=nil;if(appPEF.loaderInfoHeader.exportedSymbolCount){					if(mbin3Header)	{SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+appPEF.loaderInfoHeader.exportHashOffset+sizeof(MacBinaryIIIHeader));}	else	{SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+appPEF.loaderInfoHeader.exportHashOffset);}		exSymHash = (PEFExportedSymbolHashSlot*)NewPtr(sizeof(PEFExportedSymbolHashSlot) * (_pow(2,appPEF.loaderInfoHeader.exportHashTablePower)));	count = sizeof(PEFExportedSymbolHashSlot) * (_pow(2,appPEF.loaderInfoHeader.exportHashTablePower));	FSRead(appref,&count,exSymHash);	#ifdef __INTEL__	for(i=0;i<sizeof(PEFExportedSymbolHashSlot) * (_pow(2,appPEF.loaderInfoHeader.exportHashTablePower));i++)Swap_LONG(&exSymHash[i].countAndStart);	#endif	exSymKey = (PEFExportedSymbolKey*)NewPtr(sizeof(PEFExportedSymbolKey) * (appPEF.loaderInfoHeader.exportedSymbolCount));	count = sizeof(PEFExportedSymbolKey) * (appPEF.loaderInfoHeader.exportedSymbolCount);	FSRead(appref,&count,exSymKey);	#ifdef __INTEL__	for(i=0;i<sizeof(PEFExportedSymbolKey) * (appPEF.loaderInfoHeader.exportedSymbolCount);i++)Swap_LONG(&exSymKey[i].u.fullHashWord);	#endif	exSym = (PEFExportedSymbol*)NewPtr(sizeof(PEFExportedSymbol)*appPEF.loaderInfoHeader.exportedSymbolCount);	count = sizeof(PEFExportedSymbol)*appPEF.loaderInfoHeader.exportedSymbolCount;	FSRead(appref,&count,exSym);	#ifdef __INTEL__	for(i=0;i<sizeof(PEFExportedSymbol)*appPEF.loaderInfoHeader.exportedSymbolCount;i++)Swap_PEF_EXPORTED_SYMBOL(&exSym[i]);	#endif	//expCode=nil;	//expData=nil;	currExpCode = &expCode;	currExpData = &expData;	for(i=0;i<appPEF.loaderInfoHeader.exportedSymbolCount;i++)	{		if(exSym[i].sectionIndex==1)		{		(*currExpData) = (DataExport*)NewPtr(sizeof(DataExport));		(*currExpData)->next=nil;		(*currExpData)->offset = exSym[i].symbolValue;		j = exSymKey[i].u.splitHashWord.nameLength;		(*currExpData)->label = NewPtr(j+1);		for(k=0;k<j;k++){(*currExpData)->label[k+1]=loaderNameTable[PEFExportedSymbolNameOffset(exSym[i].classAndName)+k];}		(*currExpData)->label[0]=j;		currExpData = &((*currExpData)->next);		}		else if(exSym[i].sectionIndex==0)		{		(*currExpCode) = (CodeExport*)NewPtr(sizeof(CodeExport));		(*currExpCode)->next=nil;		(*currExpCode)->offset = exSym[i].symbolValue;		j = exSymKey[i].u.splitHashWord.nameLength;		(*currExpCode)->label = NewPtr(j+1);		for(k=0;k<j;k++){(*currExpCode)->label[k+1]=loaderNameTable[PEFExportedSymbolNameOffset(exSym[i].classAndName)+k];}		(*currExpCode)->label[0]=j;		currExpCode = &((*currExpCode)->next);		}	}DisposePtr((char*)exSymHash);DisposePtr((char*)exSymKey);DisposePtr((char*)exSym);}//security for laziness ;)    ½if(appPEF.loaderInfoHeader.relocSectionCount!=1){DebugFunction(gMultipleRelocations);}//---------------Read In Relocations---------------if(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset);}SetFPos(appref,fsFromMark,sizeof(PEFLoaderInfoHeader));SetFPos(appref,fsFromMark,sizeof(PEFImportedLibrary)*appPEF.loaderInfoHeader.importedLibraryCount);SetFPos(appref,fsFromMark,sizeof(PEFImportedSymbol)*appPEF.loaderInfoHeader.totalImportedSymbolCount);appPEF.loaderRelocationHeader = (PEFLoaderRelocationHeader*)NewPtr(sizeof(PEFLoaderRelocationHeader));count = sizeof(PEFLoaderRelocationHeader);FSRead(appref,&count,appPEF.loaderRelocationHeader);#ifdef __INTEL__Swap_PEFLoaderRelocationHeader(appPEF.loaderRelocationHeader);#endifif(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[loaderSelector].containerOffset);}SetFPos(appref,fsFromMark,appPEF.loaderInfoHeader.relocInstrOffset);relocSection = (unsigned short*)NewPtr((appPEF.loaderRelocationHeader->relocCount)*2);count = (appPEF.loaderRelocationHeader->relocCount)*2;FSRead(appref,&count,relocSection);#ifdef __INTEL__for(i=0;i<(appPEF.loaderRelocationHeader->relocCount);i++){Swap_SHORT(&(relocSection[i]));}#endif//---------------Read In Relocations---------------needsExpansion = true;//---------------Read In Data Section---------------for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFPackedDataSection){foundSection=true;break;}}if(foundSection){dataSelector = i;if(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset);}count = appPEF.sectionHeader[i].containerLength;dataSectionC = NewPtr(count);dataSectionE = nil;FSRead(appref,&count,dataSectionC);}else{for(i=0,foundSection=false;i<appPEF.containerHeader.sectionCount;i++){if(appPEF.sectionHeader[i].sectionKind == kPEFUnpackedDataSection){foundSection=true;break;}}if(foundSection){needsExpansion = false;dataSelector = i;if(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[i].containerOffset);}count = appPEF.sectionHeader[i].containerLength;dataSectionE = NewPtr(count);dataSectionC = nil;FSRead(appref,&count,dataSectionE);}else{DebugFunction(gNoDataSection);}}//---------------Read In Data Section---------------if(needsExpansion){	MyPStrAdd(appName,"\p.data",appNameWExt);	FileRef_To_FileRef_NewName(placeHolder,appNameWExt,dataSectionFile);		FSpCreate(dataSectionFile,'Doug','RSRC',smSystemScript);	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	totalWritten=0;						//---------------Expand Data Section---------------	//dataSectionE = NewPtr(appPEF.sectionHeader[dataSelector].totalLength);	dataSectionE = NewPtr(BUFF_SIZE);	if(!dataSectionE){DebugFunction("\pMemory Allocation Error");}	bm = 0;zzz=0;	k = appPEF.sectionHeader[dataSelector].containerLength;	dataCM=0;	dataEM=0;	for(;dataCM<k;)	{	#ifdef __POWERPC__	zzz++;if(!(zzz%1000)){IdleControls(GetFrontWindowOfClass(kAllWindowClasses,0));ReceiveNextEvent(0,NULL,kEventWaitTime,false,NULL);}	GetKeys(keyMap);	if(keyMap[1] == 0x00808000){gAborted=true;goto abort;}	#endif	switch((dataSectionC[dataCM]&0xE0)>>5)	{	case 0:			//Zero	{	if(dataSectionC[dataCM]&0x1F)	{	count = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(count)	}	for(i=0;i<count;i++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	break;	}	case 1:			//blockCopy	{	if(dataSectionC[dataCM]&0x1F)	{	blockSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(blockSize)	}	for(i=0;i<blockSize;i++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	break;	}	case 2:			//repeatedBlock	{	if(dataSectionC[dataCM]&0x1F)	{	blockSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(blockSize)	}	_ExtractArgument(repeatCount)	repeatCount++;//stored value is one less than actual	dataCMHolder = dataCM;	for(m=0;m<repeatCount;m++)	{	dataCM = dataCMHolder;	for(n=0;n<blockSize;n++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	}	break;	}	case 3:			//interleaveRepeatBlockWithBlockCopy	{	if(dataSectionC[dataCM]&0x1F)	{	commonSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(commonSize)	}	_ExtractArgument(customSize)	_ExtractArgument(repeatCount)	commonData = NewPtr(commonSize);	for(i=0;i<commonSize;i++)	{	commonData[i] = dataSectionC[dataCM];	dataCM++;	}	for(m=0;m<repeatCount;m++)	{	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = commonData[n];	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	for(n=0;n<customSize;n++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	}	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = commonData[n];	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	DisposePtr(commonData);	break;	}	case 4:			//interleaveRepeatBlockWithZero	{	if(dataSectionC[dataCM]&0x1F)	{	commonSize = (dataSectionC[dataCM]&0x1F);	dataCM++;	}	else	{	dataCM++;	_ExtractArgument(commonSize)	}	_ExtractArgument(customSize)	_ExtractArgument(repeatCount)	for(m=0;m<repeatCount;m++)	{	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	for(n=0;n<customSize;n++)	{	dataSectionE[dataEM] = dataSectionC[dataCM];	dataCM++;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	}	for(n=0;n<commonSize;n++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	break;	}	default: DebugFunction(gBadDataOpcode);break;	}	}	//if(appPEF.sectionHeader[dataSelector].unpackedLength != dataEM){DebugFunction(gBadDataOpcode);}	for(i=0;i<(appPEF.sectionHeader[dataSelector].totalLength-appPEF.sectionHeader[dataSelector].unpackedLength);i++)	{	dataSectionE[dataEM] = 0;	dataEM++;	if(dataEM==BUFF_SIZE){count=dataEM;FSWrite(outFRef,&count,dataSectionE);totalWritten+=count;dataEM=0;}	}	//---------------Expand Data Section---------------	//---------------Write Out Expanded Data Section---------------	count=dataEM;	FSWrite(outFRef,&count,dataSectionE);	totalWritten+=count;	SetEOF(outFRef,totalWritten);	FSClose(outFRef);	//---------------Write Out Expanded Data Section---------------}else{	MyPStrAdd(appName,"\p.data",appNameWExt);	FileRef_To_FileRef_NewName(placeHolder,appNameWExt,dataSectionFile);	FSpCreate(dataSectionFile,'Doug','RSRC',smSystemScript);	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	totalWritten=0;		count=appPEF.sectionHeader[dataSelector].totalLength;	FSWrite(outFRef,&count,dataSectionE);	totalWritten+=count;	SetEOF(outFRef,totalWritten);	FSClose(outFRef);}//---------------Write Out Relocation Instructions---------------MyPStrAdd(appName,"\p.reloc",appNameWExt);FileRef_To_FileRef_NewName(placeHolder,appNameWExt,relocSectionFile);FSpCreate(relocSectionFile,'CWIE','TEXT',smSystemScript);FSpOpenDF(relocSectionFile,fsRdWrPerm,&outFRef);totalWritten=0;rowPB.outFRef		= outFRef;rowPB.totalWritten 	= &totalWritten;rowPB.relocSize 	= (appPEF.loaderRelocationHeader->relocCount);rowPB.relocInst 	= relocSection;rowPB.section 		= appPEF.loaderRelocationHeader->sectionIndex;rowPB.pos			= 0;RelocationOpcodeWriter(&rowPB);if(gAborted){goto abort;}SetEOF(outFRef,totalWritten);FSClose(outFRef);//---------------Write Out Relocation Instructions---------------/*//---------------Write Out Section Offsets---------------MyPStrAdd(appFSSpecPtr->name,"\p.secoff",pString);MyPStrAdd("\p:",pString,resFName);MyPStrAdd(dissFolder->name,resFName,pString);MyPStrAdd("\p:",pString,resFName);FSMakeFSSpec(dissFolder->vRefNum,dissFolder->parID,resFName,outFile);FSpCreate(outFile,'Doug','RSRC',smSystemScript);FSpOpenDF(outFile,fsRdWrPerm,&outFRef);totalWritten=0;count = 4;FSWrite(outFRef,&count,&appPEF.loaderInfoHeader.mainOffset);totalWritten+=count;FSWrite(outFRef,&count,&appPEF.loaderInfoHeader.initOffset);totalWritten+=count;FSWrite(outFRef,&count,&appPEF.loaderInfoHeader.termOffset);totalWritten+=count;SetEOF(outFRef,totalWritten);FSClose(outFRef);//---------------Write Out Section Offsets---------------*/if(mbin3Header){	if(mbin3Header->resourceForkLength)	{		/*	#ifdef __POWERPC__	MyPStrAdd(appName,"\p.rsrc",appNameWExt);	FileRef_To_FileRef_NewName(placeHolder,appNameWExt,resourceSectionFile);	FSpCreateResFile((FSSpec*)resourceSectionFile,'Doug','RSRC',smSystemScript);		alignCount=(128 - (mbin3Header->dataForkLength % 128));	SetFPos(appref,fsFromStart,sizeof(MacBinaryIIIHeader)+mbin3Header->dataForkLength+alignCount);		resFork = NewPtr(mbin3Header->resourceForkLength);	count = mbin3Header->resourceForkLength;	FSRead (appref, &count, resFork);		FSpOpenRF ((FSSpec*)resourceSectionFile, fsRdWrPerm, &resRef);	count = mbin3Header->resourceForkLength;	FSWrite (resRef, &count, resFork);	FSClose (resRef);	DisposePtr(resFork);	keyfilePB.rsrc=true;	keyfilePB.rsrcmb=false;	#endif	*/		//#ifdef __INTEL__	MyPStrAdd(appName,"\p.rsrc.bin",appNameWExt);	FileRef_To_FileRef_NewName(placeHolder,appNameWExt,resourceSectionFile);	FSpCreate(resourceSectionFile,'????','????',smSystemScript);	FSpOpenDF(resourceSectionFile,fsRdWrPerm,&outFRef);	for(i=0;i<sizeof(MacBinaryIIIHeader);i++)	{((char*)&mbin3HeaderRsrc)[i]=0;}	MyPStrAdd(appName,"\p.rsrc",appNameWExt);	mbin3HeaderRsrc.fileNameLength = appNameWExt[0];	for(i=0;i<appNameWExt[0];i++){mbin3HeaderRsrc.fileName[i]=appNameWExt[i+1];}	mbin3HeaderRsrc.fileType='RSRC';	mbin3HeaderRsrc.fileCreator='Doug';	mbin3HeaderRsrc.resourceForkLength=mbin3Header->resourceForkLength;	mbin3HeaderRsrc.signature='mBIN';	mbin3HeaderRsrc.macBinaryVersion=130;	mbin3HeaderRsrc.minimumVersion=130;	#ifdef __INTEL__	Swap_MACBINARYIII_HEADER(&mbin3HeaderRsrc);	#endif	count=sizeof(MacBinaryIIIHeader);	FSWrite (outFRef, &count, &mbin3HeaderRsrc);	alignCount=(128 - (mbin3Header->dataForkLength % 128));	SetFPos(appref,fsFromStart,sizeof(MacBinaryIIIHeader)+mbin3Header->dataForkLength+alignCount);	resFork = NewPtr(mbin3Header->resourceForkLength);	count = mbin3Header->resourceForkLength;	FSRead (appref, &count, resFork);	count=mbin3Header->resourceForkLength;	FSWrite (outFRef, &count, resFork);	SetEOF(outFRef,sizeof(MacBinaryIIIHeader)+mbin3Header->resourceForkLength);	FSClose(outFRef);	DisposePtr(resFork);	keyfilePB.rsrc=false;	keyfilePB.rsrcmb=true;	//#endif	}	else	{	keyfilePB.rsrc=false;	keyfilePB.rsrcmb=false;	}}else{#ifdef __POWERPC__MyPStrAdd(appName,"\p.rsrc",appNameWExt);FileRef_To_FileRef_NewName(placeHolder,appNameWExt,resourceSectionFile);FSpCreateResFile((FSSpec*)resourceSectionFile,'Doug','RSRC',smSystemScript);CopyResources((FileReference)fref,resourceSectionFile);keyfilePB.rsrc=true;keyfilePB.rsrcmb=false;#endif#ifdef __INTEL__keyfilePB.rsrc=false;keyfilePB.rsrcmb=false;#endif}//---------------Read In Code Section---------------if(mbin3Header){SetFPos(appref,fsFromStart,appPEF.sectionHeader[codeSelector].containerOffset+sizeof(MacBinaryIIIHeader));}else{SetFPos(appref,fsFromStart,appPEF.sectionHeader[codeSelector].containerOffset);}count = appPEF.sectionHeader[codeSelector].containerLength;codeSection = (long*)NewPtr(count);FSRead(appref,&count,codeSection);#ifdef __INTEL__for(i=0;i<appPEF.sectionHeader[codeSelector].containerLength/4;i++){Swap_LONG(&(codeSection[i]));}#endif//---------------Read In Code Section---------------fragPoint.m=false;fragPoint.i=false;fragPoint.t=false;if(appPEF.loaderInfoHeader.mainSection>=0){	if(appPEF.loaderInfoHeader.mainSection!=dataSelector){DebugFunction(gGenericError);}	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	SetFPos(outFRef,fsFromStart,appPEF.loaderInfoHeader.mainOffset);	GetFPos(outFRef,&temp);	count = sizeof(long);	FSRead(outFRef,&count,&temp);	FSClose(outFRef);	//temp = (long*)&dataSectionE[appPEF.loaderInfoHeader.mainOffset];	#ifdef __INTEL__	Swap_LONG(&temp);	#endif	fragPoint.main = temp;	fragPoint.m=true;}if(appPEF.loaderInfoHeader.initSection>=0){	if(appPEF.loaderInfoHeader.initSection!=dataSelector){DebugFunction(gGenericError);}	FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	SetFPos(outFRef,fsFromStart,appPEF.loaderInfoHeader.initOffset);	count = sizeof(long);	FSRead(outFRef,&count,&temp);	FSClose(outFRef);	//temp = (long*)&dataSectionE[appPEF.loaderInfoHeader.initOffset];	#ifdef __INTEL__	Swap_LONG(&temp);	#endif	fragPoint.init = temp;	fragPoint.i=true;}if(appPEF.loaderInfoHeader.termSection>=0){	if(appPEF.loaderInfoHeader.termSection!=dataSelector){DebugFunction(gGenericError);}		FSpOpenDF(dataSectionFile,fsRdWrPerm,&outFRef);	SetFPos(outFRef,fsFromStart,appPEF.loaderInfoHeader.termOffset);	count = sizeof(long);	FSRead(outFRef,&count,&temp);	FSClose(outFRef);		//temp = (long*)&dataSectionE[appPEF.loaderInfoHeader.termOffset];	#ifdef __INTEL__	Swap_LONG(&temp);	#endif	fragPoint.term = temp;	fragPoint.t=true;}MyPStrAdd(appName,"\p.asm",appNameWExt);FileRef_To_FileRef_NewName(placeHolder,appNameWExt,codeSectionFile);FSpCreate(codeSectionFile,'CWIE','TEXT',smSystemScript);FSpOpenDF(codeSectionFile,fsRdWrPerm,&outFRef);totalWritten=0;llPB.codeLength		=	appPEF.sectionHeader[codeSelector].containerLength;llPB.codeSection	=	codeSection;llPB.fragPoint		=	fragPoint;llPB.codeExport		=	expCode;llPB.libcount		=	appPEF.loaderInfoHeader.importedLibraryCount;llPB.lib			=	impLib;llPB.sym			=	impSym;llPB.name			=	loaderNameTable;rowPB.llpb = &llPB;RelocationVM(&rowPB);llPB.rm				=	&rowPB.rMachine;mwPB.codeLength		= appPEF.sectionHeader[codeSelector].containerLength;mwPB.codeSection	= codeSection;mwPB.totalWritten	= &totalWritten;mwPB.outFRef		= outFRef;mwPB.progBar		= gAppControls.progressBar;mwPB.labelList		= MakeLabelList(&llPB);if(gAborted){goto abort;}mwPB.rm = &rowPB.rMachine;#ifdef __INTEL__SetWindowText(gAppTopText, "Writing Mnemonics...");#endif#ifdef __POWERPC__SetControl32BitMaximum(gAppControls.progressBar,((appPEF.sectionHeader[codeSelector].containerLength/4)/1000));#endifMnemonicWriter(&mwPB);if(gAborted){goto abort;}#ifdef __INTEL__//ShowWindow(gAppControls.progressBar,SW_HIDE);//ShowWindow(gAppTopText,SW_HIDE);//DestroyWindow(winProgBar);//DestroyWindow(statText);#endifImportWriter(appPEF.loaderInfoHeader.importedLibraryCount,impLib,impSym,loaderNameTable,&totalWritten,outFRef);SetEOF(outFRef,totalWritten);FSClose(outFRef);if(mbin3Header){keyfilePB.fileType = mbin3Header->fileType;keyfilePB.fileCreator = mbin3Header->fileCreator;#ifdef __INTEL__Swap_LONG(&keyfilePB.fileType);Swap_LONG(&keyfilePB.fileCreator);#endif}else{#ifdef __POWERPC__FSpMakeFSRef((FSSpec*)fref,&newRef);FSGetCatalogInfo(&newRef,kFSCatInfoFinderInfo,&catInfo,0,0,0);keyfilePB.fileType=*((long*)(&catInfo.finderInfo[0]));keyfilePB.fileCreator=*((long*)(&catInfo.finderInfo[4]));#endif#ifdef __INTEL__keyfilePB.fileType='????';keyfilePB.fileCreator='????';#endif}keyfilePB.dissFolder	= (FileReference)destRef;keyfilePB.appName		= &appName;keyfilePB.dataExports	= expData;keyfilePB.mainOffset	= appPEF.loaderInfoHeader.mainOffset;keyfilePB.initOffset	= appPEF.loaderInfoHeader.initOffset;keyfilePB.termOffset	= appPEF.loaderInfoHeader.termOffset;keyfilePB.mach			= false;keyfilePB.intel			= false;keyfilePB.cfrg			= true;WriteKeyFile(&keyfilePB);while(expData){currEDd = expData->next;DisposePtr(expData->label);DisposePtr((char*)expData);expData = currEDd;}while(expCode){currCDd = expCode->next;DisposePtr(expCode->label);DisposePtr((char*)expCode);expCode = currCDd;}abort:;#ifdef __POWERPC__if(dataSectionFile){DisposePtr((char*)dataSectionFile);}if(relocSectionFile){DisposePtr((char*)relocSectionFile);}if(codeSectionFile){DisposePtr((char*)codeSectionFile);}if(resourceSectionFile){DisposePtr((char*)resourceSectionFile);}#endifDisposePtr((char*)appPEF.sectionHeader);DisposePtr((char*)impLib);DisposePtr((char*)impSym);DisposePtr((char*)loaderNameTable);DisposePtr((char*)appPEF.loaderRelocationHeader);DisposePtr((char*)relocSection);if(dataSectionC){DisposePtr((char*)dataSectionC);}if(dataSectionE){DisposePtr((char*)dataSectionE);}DisposePtr((char*)codeSection);if(!gAborted){thenow = rowPB.rMachine.sym;while(thenow){forbye = thenow;thenow = thenow->next;DisposePtr(forbye->label);DisposePtr((char*)forbye);}}else{thenow = rowPB.rMachine.sym;while(thenow && IsPointerValid((char*)thenow)){forbye = thenow;thenow = thenow->next;if(IsPointerValid(forbye->label)){DisposePtr(forbye->label);}if(IsPointerValid((char*)forbye)){DisposePtr((char*)forbye);}}}#ifdef __POWERPC__//TransitionWindow(gAppWindow,kWindowZoomTransitionEffect,kWindowHideTransitionAction,NULL);#endifgAborted=false;}