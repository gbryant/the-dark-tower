Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define	_WRITE_(X,Y)			\							\for(k=0;k<X;k++)			\{							\buffer[bm] = Y[k];bm++;		\}#define	_WRITE_STRING(X)			\							\for(k=0;k<(sizeof(X)-1);k++)			\{							\buffer[bm] = X[k];bm++;		\}void MnemonicWriter386(MnemonicWriterPBlock	*mwPB){Boolean					boolVal;long					counter,prevVal;unsigned long			instIndex,i,k;unsigned long			loopVal;unsigned long			count;MnemonicPBlock			mnPB;LabelList				*currLabelList;LabelList				*tempLL;KeyMap					keyMap;Rect					winBound;Str255					str;char *buffer;long bm,zzz=0;#ifdef __POWERPC__SetControlData(gAppControls.statusText, kControlEditTextPart,kControlStaticTextTextTag,sizeof("    Writing Mnemonics...")-1,"    Writing Mnemonics...");DrawControls(gAppWindow);#endifbuffer = NewPtr(0x210000);	bm=0;for(i=0;i<mwPB->codeLength;i++)	{	zzz++;		#ifdef __POWERPC__		SetControl32BitValue(mwPB->progBar,i/1000);		if(!(zzz%1000))		{ReceiveNextEvent(0,NULL,kEventWaitTime,false,NULL);}		#endif		#ifdef __INTEL__		SendMessage((HWND)mwPB->progBar,PBM_SETPOS,i/1000,0);		#endif				switch(mwPB->codeSection2[i])		{			case 0x10:			case 0x11:			case 0x12:			case 0x13:			case 0x14:			case 0x15:			case 0x80:			case 0x81:			case 0x82:			case 0x83:			{				_WRITE_STRING("adc\t\t\t")				i++;				switch(mwPB->codeSection2[i])				{								}			break;			}						case 0x27:			{			_WRITE_STRING("daa")			_WRITE_STRING("\r")			break;			}			case 0x37:			{			_WRITE_STRING("aaa")			_WRITE_STRING("\r")			break;			}			case 0x3F:			{			_WRITE_STRING("aas")			_WRITE_STRING("\r")			break;			}			case 0x50:			{			_WRITE_STRING("push\t\teax\r")			break;			}			case 0x51:			{			_WRITE_STRING("push\t\tecx\r")			break;			}			case 0x52:			{			_WRITE_STRING("push\t\tedx\r")			break;			}			case 0x53:			{			_WRITE_STRING("push\t\tebx\r")			break;			}			case 0x54:			{			_WRITE_STRING("push\t\tesp\r")			break;			}			case 0x55:			{			_WRITE_STRING("push\t\tebp\r")			break;			}			case 0x56:			{			_WRITE_STRING("push\t\tesi\r")			break;			}			case 0x57:			{			_WRITE_STRING("push\t\tedi\r")			break;			}			case 0x89:			{				_WRITE_STRING("mov\t\t\t")				i++;				switch(mwPB->codeSection2[i])				{					case 0xE5:					{					_WRITE_STRING("ebp,esp\r")					break;					}					default:_WRITE_STRING("\r");break;				}			break;			}			case 0x8B:			{			_WRITE_STRING("mov\r")			i+=2;			break;			}			case 0x90:			{			_WRITE_STRING("nop\r")			break;			}			case 0xC3:			case 0xCB:			{			_WRITE_STRING("ret\r")			break;			}			case 0xC9:			{			_WRITE_STRING("leave\r")			break;			}			case 0xD4:			{				i++;				switch(mwPB->codeSection2[i])				{					case 10:_WRITE_STRING("aam\r");break;					default:					{					_WRITE_STRING("aam\t\t\t")					NumberToString((long)(signed char)mwPB->codeSection2[i],(char*)str);					_WRITE_(str[0],(str+1))					_WRITE_STRING("\r")					break;					}				}			break;			}			case 0xD5:			{				i++;				switch(mwPB->codeSection2[i])				{					case 10:_WRITE_STRING("aad\r");break;					default:					{					_WRITE_STRING("aad\t\t\t")					NumberToString((long)(signed char)mwPB->codeSection2[i],(char*)str);					_WRITE_(str[0],(str+1))					_WRITE_STRING("\r")					break;					}				}			break;			}			//default:_WRITE_STRING("\r");break;		}			if(bm>=0x200000)		{			count = bm;			FSWrite(mwPB->outFRef,&count,buffer);			*(mwPB->totalWritten)+=count;			bm=0;		}			}if(bm)	{		count = bm;		FSWrite(mwPB->outFRef,&count,buffer);		*(mwPB->totalWritten)+=count;		bm=0;	}DisposePtr(buffer);}