Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define	INTEL_NAME_APPEND(X,Y)												\																			\ZeroMemory(&Y,MAX_PATH);													\i=0;																		\while(((char*)destRef)[i]!=0){Y[i] = ((char*)destRef)[i];i++;}				\Y[i]=0;																		\i=0;while(((char*)fref)[i]!=0){i++;}										\while(((char*)fref)[i]!='\\'){i--;}a=i+1;									\i=0;while(((char*)Y)[i]!=0){i++;}((char*)Y)[i]='\\';i++;					\while(((char*)fref)[a]!=0){((char*)Y)[i] = ((char*)fref)[a];i++;a++;}		\for(a=0;a<(sizeof(X)-1);a++,i++){((char*)Y)[i]=X[a];}						\((char*)Y)[i]=0;#define _WRITE(X,Y)							\											\count=X;									\FSWrite(outInfoRef,&count,Y);				\totalWritten2+=count;#define WRITE_TAB(X)								\for(z=0;z<X;z++)									\{													\count = 1;											\FSWrite(outInfoRef,&count,"\t");					\totalWritten2 += count;								\}#define		PPC_THREAD_WRITE(X,Y)				\WRITE_STRING(X)									\hex2char(ppcThreadState->Y,number);				\WRITE_STRING("0x")								\k=0;while(number[k]=='0'&&k<7){k++;}			\_WRITE(8-k,number+k)							\WRITE_STRING("\r")#define WRITE_STRING(X)					\count=sizeof(X)-1;						\FSWrite(outInfoRef,&count,X);			\totalWritten2+=count;void DisassembleMachO(void	*fref, void	*destRef){LabelListPBlock			llPB;RelocOpWriterPBlock		rowPB;MnemonicWriterPBlock	mwPB;LabelList				topLabelList,*currLabelList;Str255					tempPStr;FoundBranches			*foundBranches;FoundBranches			*currFB;LabelList				*labelList;mach_header				machHeader;segment_command			*segmentCommand=0;symtab_command			*symTabCommand=0;symseg_command			*symSegCommand=0;thread_command			*threadCommand=0;fvmlib_command			*fvmLibCommand=0;fvmfile_command			*fvmFileCommand=0;dysymtab_command		*dySymTabCommand=0;dylib_command			*dyLibCommand=0;dylinker_command		*dyLinkerCommand=0;prebound_dylib_command	*preBoundDyLibCommand=0;twolevel_hints_command	*twoLevelHintCommand=0;prebind_cksum_command	*prebindCksumCommand=0;sub_framework_command	*subFrameworkCommand=0;load_command			*genericCommand=0;section					*theSection=0;ppc_thread_state		*ppcThreadState=0;routines_command		*routinesCommand=0;sub_umbrella_command	*subUmbrellaCommand=0;sub_client_command		*subClientCommand=0;sub_library_command		*subLibraryCommand=0;struct nlist			*symbolEntry=0;char					*stringTable=0;twolevel_hint			*hints=0;Boolean					flag;KeyFilePB				keyfilePB;#ifdef __POWERPC__FSSpec					*infoFile,*asmFile;#endif#ifdef __INTEL__char					infoFile[MAX_PATH];char					asmFile[MAX_PATH];#endifchar					*machCommands=0;long					offset,offset2;unsigned long			count;long					i,j,k,a;long					*codeSection=0;Str255					pString,resFName;void					*outFRef,*outInfoRef;long					totalWritten,totalWritten2;FragPoint				fragPoint;Str255 					winTitle;fat_header				fatHeader;fat_arch				*fatArchHeader=0;unsigned long			fatArchOffset;Boolean					archFound,boolVal,fatArch;void					*appref=0;char					number[256];char					*inData=0;long					tabcount,inPos,z,totalData,cmdcount;FSCatalogInfo 			catInfo;#ifdef __POWERPC__asmFile	=	(FSSpec*)NewPtr(sizeof(FSSpec));infoFile	=	(FSSpec*)NewPtr(sizeof(FSSpec));#endiffatArch=false;FSpOpenDF(fref,fsRdPerm,&appref);count = sizeof(mach_header);FSRead(appref,&count,&machHeader);#ifdef __INTEL__Swap_MACH_HEADER(&machHeader);#endifif(machHeader.magic!=0xFEEDFACE){SetFPos(appref,fsFromStart,0);count = sizeof(fat_header);FSRead(appref,&count,&fatHeader);if(fatHeader.magic!=0xCAFEBABE){DebugFunction(gGenericError);}fatArchHeader = (fat_arch*)NewPtr(sizeof(fat_arch)*fatHeader.nfat_arch);count = sizeof(fat_arch)*fatHeader.nfat_arch;FSRead(appref,&count,fatArchHeader);archFound=false;for(i=0;i<fatHeader.nfat_arch;i++){if(fatArchHeader[i].cputype==CPU_TYPE_POWERPC){archFound=true;break;}}if(!archFound){DebugFunction(gGenericError);}fatArch = true;fatArchOffset = fatArchHeader[i].offset;SetFPos(appref,fsFromStart,fatArchHeader[i].offset);count = sizeof(mach_header);FSRead(appref,&count,&machHeader);}if(machHeader.cputype==CPU_TYPE_POWERPC){keyfilePB.dissFolder	= (FileReference)destRef;#ifdef __POWERPC__keyfilePB.appName		= (Str255*)(&((FSSpec*)fref)->name);#endifkeyfilePB.mach			= true;keyfilePB.intel			= false;keyfilePB.cfrg			= false;WriteKeyFile(&keyfilePB);#ifdef __INTEL__DebugFunction("\pPC Testing...");#endif#ifdef __POWERPC__MyPStrAdd(((FSSpec*)fref)->name,"\p.info",pString);MyPStrAdd("\p:",pString,resFName);MyPStrAdd(((FSSpec*)destRef)->name,resFName,pString);MyPStrAdd("\p:",pString,resFName);FSMakeFSSpec(((FSSpec*)destRef)->vRefNum,((FSSpec*)destRef)->parID,resFName,infoFile);#endif#ifdef __INTEL__INTEL_NAME_APPEND(".info",infoFile)#endifFSpCreate(infoFile,'CWIE','TEXT',smSystemScript);FSpOpenDF(infoFile,fsRdWrPerm,&outInfoRef);totalWritten2=0;	machCommands = NewPtr(machHeader.sizeofcmds);	count = machHeader.sizeofcmds;	FSRead(appref,&count,machCommands);		offset = 0;	for(cmdcount=0;cmdcount<machHeader.ncmds;cmdcount++)	{			WRITE_STRING("@command: ")			switch(*((long*)(machCommands+offset)))		{			case LC_SEGMENT:			{				segmentCommand = (segment_command*)(machCommands+offset);								WRITE_STRING("LC_SEGMENT\r{\r")				WRITE_STRING("name:\t\t")				for(k=0;segmentCommand->segname[k]!=0;k++){}				_WRITE(k,segmentCommand->segname)				WRITE_STRING("\r")					hex2char(segmentCommand->vmaddr,number);				WRITE_STRING("vmaddr:\t\t0x")				k=0;while(number[k]=='0'&&k<7){k++;}				_WRITE(8-k,number+k)				WRITE_STRING("\r")				hex2char(segmentCommand->vmsize,number);				WRITE_STRING("vmsize:\t\t0x")				k=0;while(number[k]=='0'&&k<7){k++;}				_WRITE(8-k,number+k)				WRITE_STRING("\r")				hex2char(segmentCommand->fileoff,number);				WRITE_STRING("fileoff:\t0x")				k=0;while(number[k]=='0'&&k<7){k++;}				_WRITE(8-k,number+k)				WRITE_STRING("\r")				hex2char(segmentCommand->filesize,number);				WRITE_STRING("filesize:\t0x")				k=0;while(number[k]=='0'&&k<7){k++;}				_WRITE(8-k,number+k)				WRITE_STRING("\r")				NumberToString(segmentCommand->maxprot,number);				WRITE_STRING("maxprot:\t")								flag=false;				if(segmentCommand->maxprot>=4){segmentCommand->maxprot-=4;WRITE_STRING("VM_PROT_EXECUTE");flag=true;}				if(segmentCommand->maxprot>=2){if(flag){WRITE_STRING(", ")}segmentCommand->maxprot-=2;WRITE_STRING("VM_PROT_WRITE");flag=true;}				if(segmentCommand->maxprot>=1){if(flag){WRITE_STRING(", ")}segmentCommand->maxprot-=1;WRITE_STRING("VM_PROT_READ");flag=true;}				if(segmentCommand->maxprot!=0){if(flag){WRITE_STRING(", ")};WRITE_STRING("ERROR");WRITE_STRING(":");_WRITE(number[0],number+1);flag=true;}				if(!flag){WRITE_STRING("VM_PROT_NONE")}				WRITE_STRING("\r")								//_WRITE(number[0],number+1)				//_WRITE(1,"\r")								NumberToString(segmentCommand->initprot,number);				WRITE_STRING("initprot:\t")								flag=false;				if(segmentCommand->initprot>=4){segmentCommand->initprot-=4;WRITE_STRING("VM_PROT_EXECUTE");flag=true;}				if(segmentCommand->initprot>=2){if(flag){WRITE_STRING(", ")}segmentCommand->initprot-=2;WRITE_STRING("VM_PROT_WRITE");flag=true;}				if(segmentCommand->initprot>=1){if(flag){WRITE_STRING(", ")}segmentCommand->initprot-=1;WRITE_STRING("VM_PROT_READ");flag=true;}				if(segmentCommand->initprot!=0){if(flag){WRITE_STRING(", ")};WRITE_STRING("ERROR");WRITE_STRING(":");_WRITE(number[0],number+1);flag=true;}				if(!flag){WRITE_STRING("VM_PROT_NONE")}				WRITE_STRING("\r")												//_WRITE(number[0],number+1)				//_WRITE(1,"\r")								NumberToString(segmentCommand->flags,number);				WRITE_STRING("flags:\t\t")								flag=false;				if(segmentCommand->flags>=4){segmentCommand->flags-=4;WRITE_STRING("SG_NORELOC");flag=true;}				if(segmentCommand->flags>=2){if(flag){WRITE_STRING(", ")}segmentCommand->flags-=2;WRITE_STRING("SG_FVMLIB");flag=true;}				if(segmentCommand->flags>=1){if(flag){WRITE_STRING(", ")}segmentCommand->flags-=1;WRITE_STRING("SG_HIGHVM");flag=true;}				if(segmentCommand->flags!=0){if(flag){WRITE_STRING(", ")};WRITE_STRING("ERROR");WRITE_STRING(":");_WRITE(number[0],number+1);flag=true;}				if(!flag){WRITE_STRING("0")}				WRITE_STRING("\r")																if(segmentCommand->nsects){WRITE_STRING("sections:\r{\r")}								offset2 = offset;				offset2+=sizeof(segment_command);				for(j=0;j<segmentCommand->nsects;j++)				{					theSection = (section*)(machCommands+offset2);										WRITE_STRING("name: ")										for(k=0;theSection->sectname[k]!=0;k++){}					_WRITE(k,theSection->sectname)					WRITE_STRING("\r{\r")					hex2char(theSection->addr,number);					WRITE_STRING("addr:\t0x")					k=0;while(number[k]=='0'&&k<7){k++;}					_WRITE(8-k,number+k)					WRITE_STRING("\r")					hex2char(theSection->size,number);					WRITE_STRING("size:\t0x")					k=0;while(number[k]=='0'&&k<7){k++;}					_WRITE(8-k,number+k)					WRITE_STRING("\r")					hex2char(theSection->offset,number);					WRITE_STRING("offset:\t0x")					k=0;while(number[k]=='0'&&k<7){k++;}					_WRITE(8-k,number+k)					WRITE_STRING("\r")					NumberToString(theSection->align,number);					WRITE_STRING("align:\t")					_WRITE(number[0],number+1)					WRITE_STRING("\r")					hex2char(theSection->reloff,number);					WRITE_STRING("reloff:\t0x")					k=0;while(number[k]=='0'&&k<7){k++;}					_WRITE(8-k,number+k)					WRITE_STRING("\r")					NumberToString(theSection->nreloc,number);					WRITE_STRING("nreloc:\t")					_WRITE(number[0],number+1)					WRITE_STRING("\r")					WRITE_STRING("section type:\t\t")					switch(theSection->flags&SECTION_TYPE)					{					case S_REGULAR: WRITE_STRING("S_REGULAR\r");break;					case S_ZEROFILL: WRITE_STRING("S_ZEROFILL\r");break;					case S_CSTRING_LITERALS: WRITE_STRING("S_CSTRING_LITERALS\r");break;					case S_4BYTE_LITERALS: WRITE_STRING("S_4BYTE_LITERALS\r");break;					case S_8BYTE_LITERALS: WRITE_STRING("S_8BYTE_LITERALS\r");break;					case S_LITERAL_POINTERS: WRITE_STRING("S_LITERAL_POINTERS\r");break;					case S_NON_LAZY_SYMBOL_POINTERS: WRITE_STRING("S_NON_LAZY_SYMBOL_POINTERS\r");break;					case S_LAZY_SYMBOL_POINTERS: WRITE_STRING("S_LAZY_SYMBOL_POINTERS\r");break;					case S_SYMBOL_STUBS: WRITE_STRING("S_SYMBOL_STUBS\r");break;					case S_MOD_INIT_FUNC_POINTERS: WRITE_STRING("S_MOD_INIT_FUNC_POINTERS\r");break;					case S_MOD_TERM_FUNC_POINTERS: WRITE_STRING("S_MOD_TERM_FUNC_POINTERS\r");break;					case S_COALESCED: WRITE_STRING("S_COALESCED\r");break;					default:							{							hex2char(theSection->flags&SECTION_TYPE,number);							WRITE_STRING("0x")							k=0;while(number[k]=='0'&&k<7){k++;}							_WRITE(8-k,number+k)							break;							}					}										WRITE_STRING("section attributes:\t")															flag=false;										if(theSection->flags&S_ATTR_PURE_INSTRUCTIONS){WRITE_STRING("S_ATTR_PURE_INSTRUCTIONS");flag=true;}					if(theSection->flags&S_ATTR_NO_TOC){if(flag){WRITE_STRING(", ")}WRITE_STRING("S_ATTR_NO_TOC");flag=true;}					if(theSection->flags&S_ATTR_STRIP_STATIC_SYMS){if(flag){WRITE_STRING(", ")}WRITE_STRING("S_ATTR_STRIP_STATIC_SYMS");flag=true;}					if(theSection->flags&S_ATTR_SOME_INSTRUCTIONS){if(flag){WRITE_STRING(", ")}WRITE_STRING("S_ATTR_SOME_INSTRUCTIONS");flag=true;}					if(theSection->flags&S_ATTR_EXT_RELOC){if(flag){WRITE_STRING(", ")}WRITE_STRING("S_ATTR_EXT_RELOC");flag=true;}					if(theSection->flags&S_ATTR_LOC_RELOC){if(flag){WRITE_STRING(", ")}WRITE_STRING("S_ATTR_LOC_RELOC");flag=true;}					/*					if(theSection->flags&SECTION_ATTRIBUTES_USR)					{					if(flag){WRITE_STRING(", ")}					WRITE_STRING("SECTION_ATTRIBUTES_USR:")					NumberToString((theSection->flags&SECTION_ATTRIBUTES_USR)>>24,number);					_WRITE(number[0],number+1)					flag=true;					}					if(theSection->flags&SECTION_ATTRIBUTES_SYS)					{					if(flag){WRITE_STRING(", ")}					WRITE_STRING("SECTION_ATTRIBUTES_SYS:")					NumberToString((theSection->flags&SECTION_ATTRIBUTES_SYS)>>8,number);					_WRITE(number[0],number+1)					flag=true;					}					*/					if(!flag){WRITE_STRING("0x0")}					else					{					hex2char(theSection->flags&SECTION_ATTRIBUTES,number);					WRITE_STRING(": 0x")					k=0;while(number[k]=='0'&&k<7){k++;}					_WRITE(8-k,number+k)					}										WRITE_STRING("\r");					NumberToString(theSection->reserved1,number);					WRITE_STRING("reserved1:\t\t\t")					_WRITE(number[0],number+1)					WRITE_STRING("\r")					NumberToString(theSection->reserved2,number);					WRITE_STRING("reserved2:\t\t\t")					_WRITE(number[0],number+1)					WRITE_STRING("\r")															WRITE_STRING("}\r")										if(MyCStrCmp(theSection->segname,"__TEXT"))					{						if(MyCStrCmp(theSection->sectname,"__text"))						{						fragPoint.m=false;						fragPoint.i=false;						fragPoint.t=false;																		DT_SetProgressState(gAppControls.progressBar,kControlProgressBarIndeterminateTag,true);																								codeSection = (long*)NewPtr(theSection->size);						count = theSection->size;						if(!fatArch)						{SetFPos(appref,fsFromStart,theSection->offset);}						else						{SetFPos(appref,fsFromStart,theSection->offset+fatArchOffset);}						FSRead(appref,&count,codeSection);												#ifdef __POWERPC__						MyPStrAdd(((FSSpec*)fref)->name,"\p.asm",pString);						MyPStrAdd("\p:",pString,resFName);						MyPStrAdd(((FSSpec*)destRef)->name,resFName,pString);						MyPStrAdd("\p:",pString,resFName);						FSMakeFSSpec(((FSSpec*)destRef)->vRefNum,((FSSpec*)destRef)->parID,resFName,asmFile);						#endif												#ifdef __INTEL__						INTEL_NAME_APPEND(".asm",asmFile)						#endif																		FSpCreate(asmFile,'CWIE','TEXT',smSystemScript);						FSpOpenDF(asmFile,fsRdWrPerm,&outFRef);						totalWritten=0;																		llPB.codeSection	=	codeSection;						llPB.codeLength		=	theSection->size;						llPB.fragPoint.m 	=	false;						llPB.fragPoint.i 	=	false;						llPB.fragPoint.t 	=	false;						llPB.codeExport		=	nil;												rowPB.rMachine.sym	=	nil;						llPB.rm				=	&rowPB.rMachine;																		mwPB.codeLength		= theSection->size;						mwPB.codeSection	= codeSection;						mwPB.totalWritten	= &totalWritten;						mwPB.outFRef		= outFRef;												#ifdef __POWERPC__						mwPB.progBar		= gAppControls.progressBar;						#endif												mwPB.labelList		= MakeLabelList(&llPB);																		DT_SetProgressState(gAppControls.progressBar,kControlProgressBarIndeterminateTag,false);																								#ifdef __POWERPC__						SetControl32BitMaximum(gAppControls.progressBar,(theSection->size/4)/1000);						#endif												mwPB.rm = &rowPB.rMachine;												MnemonicWriter(&mwPB);																						SetEOF(outFRef,totalWritten);						FSClose(outFRef);						}					}					offset2+=sizeof(section);				}				if(segmentCommand->nsects){WRITE_STRING("}\r")}				WRITE_STRING("}\r\r")				offset+=segmentCommand->cmdsize;			break;			}			case LC_SYMTAB:			{			WRITE_STRING("LC_SYMTAB\r{\r")			symTabCommand = (symtab_command*)(machCommands+offset);						NumberToString(symTabCommand->symoff,number);			WRITE_STRING("symoff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")			NumberToString(symTabCommand->nsyms,number);			WRITE_STRING("nsyms: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")			NumberToString(symTabCommand->stroff,number);			WRITE_STRING("stroff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")			NumberToString(symTabCommand->strsize,number);			WRITE_STRING("strsize: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r{\r")						symbolEntry = (struct nlist*)NewPtr(sizeof(struct nlist)*symTabCommand->nsyms);			if (!fatArch)			{SetFPos(appref,fsFromStart,symTabCommand->symoff);}			else			{SetFPos(appref,fsFromStart,symTabCommand->symoff+fatArchOffset);}			count = sizeof(struct nlist)*symTabCommand->nsyms;			FSRead(appref,&count,symbolEntry);						stringTable = NewPtr(symTabCommand->strsize);			if (!fatArch)			{SetFPos(appref,fsFromStart,symTabCommand->stroff);}			else			{SetFPos(appref,fsFromStart,symTabCommand->stroff+fatArchOffset);}			count = symTabCommand->strsize;			FSRead(appref,&count,stringTable);						for(i=0;i<symTabCommand->nsyms;i++)			{				WRITE_STRING("symbol: ")				NumberToString(i+1,number);				_WRITE(number[0],number+1)				WRITE_STRING("\r")				WRITE_STRING("n_type: ")				flag=false;				if(symbolEntry[i].n_type & N_STAB)				{					WRITE_STRING("N_STAB: ")					switch(symbolEntry[i].n_type & N_STAB)					{					case N_GSYM: WRITE_STRING("N_GSYM");break;					case N_FNAME: WRITE_STRING("N_FNAME");break;					case N_FUN: WRITE_STRING("N_FUN");break;					case N_STSYM: WRITE_STRING("N_STSYM");break;					case N_LCSYM: WRITE_STRING("N_LCSYM");break;					case N_BNSYM: WRITE_STRING("N_BNSYM");break;					case N_RSYM: WRITE_STRING("N_RSYM");break;					case N_SLINE: WRITE_STRING("N_SLINE");break;					case N_ENSYM: WRITE_STRING("N_ENSYM");break;					case N_SSYM: WRITE_STRING("N_SSYM");break;					case N_SO: WRITE_STRING("N_SO");break;					case N_LSYM: WRITE_STRING("N_LSYM");break;					case N_BINCL: WRITE_STRING("N_BINCL");break;					case N_SOL: WRITE_STRING("N_SOL");break;					case N_PSYM: WRITE_STRING("N_PSYM");break;					case N_EINCL: WRITE_STRING("N_EINCL");break;					case N_ENTRY: WRITE_STRING("N_ENTRY");break;					case N_LBRAC: WRITE_STRING("N_LBRAC");break;					case N_EXCL: WRITE_STRING("N_EXCL");break;					case N_RBRAC: WRITE_STRING("N_RBRAC");break;					case N_BCOMM: WRITE_STRING("N_BCOMM");break;					case N_ECOMM: WRITE_STRING("N_ECOMM");break;					case N_ECOML: WRITE_STRING("N_ECOML");break;					case N_LENG: WRITE_STRING("N_LENG");break;					case N_PC: WRITE_STRING("N_PC");break;					default: 							{							WRITE_STRING("UNKNOWN: ");break;							NumberToString((symbolEntry[i].n_type & N_STAB),number);							_WRITE(number[0],number+1)							}					}				}				else				{					if(symbolEntry[i].n_type &  N_PEXT){WRITE_STRING("N_PEXT");flag=true;}					if(symbolEntry[i].n_type &  N_EXT){if(flag){WRITE_STRING(", ")}WRITE_STRING("N_EXT");flag=true;}					if(symbolEntry[i].n_type &  N_TYPE)					{						if(flag){WRITE_STRING(", ")}						WRITE_STRING("N_TYPE: ")						switch(symbolEntry[i].n_type &  N_TYPE)						{						case N_ABS:WRITE_STRING("N_ABS");break;						case N_SECT:WRITE_STRING("N_SECT");break;						case N_PBUD:WRITE_STRING("N_PBUD");break;						case N_INDR:WRITE_STRING("N_INDR");break;						}					}					else					{//						if(flag){WRITE_STRING(", ")}						WRITE_STRING("N_TYPE: N_UNDF")						WRITE_STRING(": ")						switch(symbolEntry[i].n_desc & REFERENCE_TYPE)						{						case REFERENCE_FLAG_UNDEFINED_NON_LAZY:WRITE_STRING("REFERENCE_FLAG_UNDEFINED_NON_LAZY");break;						case REFERENCE_FLAG_UNDEFINED_LAZY:WRITE_STRING("REFERENCE_FLAG_UNDEFINED_LAZY");break;						case REFERENCE_FLAG_DEFINED:WRITE_STRING("REFERENCE_FLAG_DEFINED");break;						case REFERENCE_FLAG_PRIVATE_DEFINED:WRITE_STRING("REFERENCE_FLAG_PRIVATE_DEFINED");break;						case REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY:WRITE_STRING("REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY");break;						case REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY:WRITE_STRING("REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY");break;						default:NumberToString(symbolEntry[i].n_desc & REFERENCE_TYPE,number);_WRITE(number[0],number+1);break;						}						}				}				//sym entry for undf? - 01020591034								if(symbolEntry[i].n_un.n_strx>0 && symbolEntry[i].n_un.n_strx<symTabCommand->strsize)				{					for(k=0;stringTable[symbolEntry[i].n_un.n_strx+k]!=0&&(symbolEntry[i].n_un.n_strx+k)<=symTabCommand->strsize;k++){}					if(k)					{					WRITE_STRING("\r")					WRITE_STRING("string: ")					_WRITE(k,(char*)stringTable+symbolEntry[i].n_un.n_strx)					}				}			WRITE_STRING("\r\r")			}						WRITE_STRING("}\r}\r\r")			offset+=symTabCommand->cmdsize;			break;			}			case LC_SYMSEG:			{			WRITE_STRING("LC_SYMSEG\r\r")			symSegCommand = (symseg_command*)(machCommands+offset);			offset+=symSegCommand->cmdsize;			break;			}			case LC_THREAD:			case LC_UNIXTHREAD:			{			if((*((long*)(machCommands+offset)))==LC_THREAD)			{WRITE_STRING("LC_THREAD")}			if((*((long*)(machCommands+offset)))==LC_UNIXTHREAD)			{WRITE_STRING("LC_UNIXTHREAD")}						WRITE_STRING("\r{\r")			threadCommand = (thread_command*)(machCommands+offset);			WRITE_STRING("flavor: ")			switch(threadCommand->flavor)			{			case PPC_THREAD_STATE: 					{					WRITE_STRING("PPC_THREAD_STATE\r")					NumberToString(threadCommand->count,number);					WRITE_STRING("count: ")					_WRITE(number[0],number+1)					WRITE_STRING("\r{\r")					ppcThreadState = (ppc_thread_state*)(machCommands+offset+16);					PPC_THREAD_WRITE("srr0:\t",srr0);					PPC_THREAD_WRITE("srr1:\t",srr1);					PPC_THREAD_WRITE("r0:\t\t",r0);					PPC_THREAD_WRITE("r1:\t\t",r1);					PPC_THREAD_WRITE("r2:\t\t",r2);					PPC_THREAD_WRITE("r3:\t\t",r3);					PPC_THREAD_WRITE("r4:\t\t",r4);					PPC_THREAD_WRITE("r5:\t\t",r5);					PPC_THREAD_WRITE("r6:\t\t",r6);					PPC_THREAD_WRITE("r7:\t\t",r7);					PPC_THREAD_WRITE("r8:\t\t",r8);					PPC_THREAD_WRITE("r9:\t\t",r9);								PPC_THREAD_WRITE("r10:\t",r10);					PPC_THREAD_WRITE("r11:\t",r11);					PPC_THREAD_WRITE("r12:\t",r12);					PPC_THREAD_WRITE("r13:\t",r13);					PPC_THREAD_WRITE("r14:\t",r14);					PPC_THREAD_WRITE("r15:\t",r15);					PPC_THREAD_WRITE("r16:\t",r16);					PPC_THREAD_WRITE("r17:\t",r17);					PPC_THREAD_WRITE("r18:\t",r18);					PPC_THREAD_WRITE("r19:\t",r19);					PPC_THREAD_WRITE("r20:\t",r20);					PPC_THREAD_WRITE("r21:\t",r21);					PPC_THREAD_WRITE("r22:\t",r22);					PPC_THREAD_WRITE("r23:\t",r23);					PPC_THREAD_WRITE("r24:\t",r24);					PPC_THREAD_WRITE("r25:\t",r25);					PPC_THREAD_WRITE("r26:\t",r26);					PPC_THREAD_WRITE("r27:\t",r27);					PPC_THREAD_WRITE("r28:\t",r28);					PPC_THREAD_WRITE("r29:\t",r29);					PPC_THREAD_WRITE("r30:\t",r30);						PPC_THREAD_WRITE("r31:\t",r31);					PPC_THREAD_WRITE("cr:\t\t",cr);					PPC_THREAD_WRITE("xer:\t",xer);					PPC_THREAD_WRITE("lr:\t\t",lr);					PPC_THREAD_WRITE("ctr:\t",ctr);					PPC_THREAD_WRITE("mq:\t\t",mq);					PPC_THREAD_WRITE("vrsave:\t",vrsave);					WRITE_STRING("}\r")					break;					}			case PPC_FLOAT_STATE: 					{					WRITE_STRING("PPC_FLOAT_STATE\r")					NumberToString(threadCommand->count,number);					WRITE_STRING("count: ")					_WRITE(number[0],number+1)					WRITE_STRING("\r")					break;					}			case PPC_EXCEPTION_STATE: 					{					WRITE_STRING("PPC_EXCEPTION_STATE\r")					NumberToString(threadCommand->count,number);					WRITE_STRING("count: ")					_WRITE(number[0],number+1)					WRITE_STRING("\r")					break;					}			case PPC_VECTOR_STATE: 					{					WRITE_STRING("PPC_VECTOR_STATE\r")					NumberToString(threadCommand->count,number);					WRITE_STRING("count: ")					_WRITE(number[0],number+1)					WRITE_STRING("\r")					break;					}			case THREAD_STATE_NONE: 					{					WRITE_STRING("THREAD_STATE_NONE\r")					NumberToString(threadCommand->count,number);					WRITE_STRING("count: ")					_WRITE(number[0],number+1)					WRITE_STRING("\r")					break;					}			default: {						WRITE_STRING("UNKNOWN_THREAD_STATE: ")						NumberToString(threadCommand->flavor,number);						_WRITE(number[0],number+1)						WRITE_STRING("\r")						NumberToString(threadCommand->count,number);						WRITE_STRING("count: ")						_WRITE(number[0],number+1)						WRITE_STRING("\r")					 }			}					WRITE_STRING("}\r\r")			offset+=threadCommand->cmdsize;			break;			}			case LC_LOADFVMLIB:			{			WRITE_STRING("LC_LOADFVMLIB\r{\r")			fvmLibCommand = (fvmlib_command*)(machCommands+offset);						WRITE_STRING("path: ")			for(k=0;((char*)fvmLibCommand+fvmLibCommand->fvmlib.name.offset)[k]!=0;k++){}			_WRITE(k,((char*)fvmLibCommand+fvmLibCommand->fvmlib.name.offset))			WRITE_STRING("\r")			WRITE_STRING("minor_version: 0x")			hex2char(fvmLibCommand->fvmlib.minor_version,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")			WRITE_STRING("header_addr: 0x")			hex2char(fvmLibCommand->fvmlib.header_addr,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")						WRITE_STRING("}\r\r")			offset+=fvmLibCommand->cmdsize;			break;			}			case LC_IDFVMLIB:			{			WRITE_STRING("LC_IDFVMLIB\r{\r")			fvmLibCommand = (fvmlib_command*)(machCommands+offset);						WRITE_STRING("path: ")			for(k=0;((char*)fvmLibCommand+fvmLibCommand->fvmlib.name.offset)[k]!=0;k++){}			_WRITE(k,((char*)fvmLibCommand+fvmLibCommand->fvmlib.name.offset))			WRITE_STRING("\r")			WRITE_STRING("minor_version: 0x")			hex2char(fvmLibCommand->fvmlib.minor_version,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")			WRITE_STRING("header_addr: 0x")			hex2char(fvmLibCommand->fvmlib.header_addr,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")						WRITE_STRING("}\r\r")			offset+=fvmLibCommand->cmdsize;			break;			}			case LC_IDENT:			{			WRITE_STRING("LC_IDENT\r\r")			genericCommand = (load_command*)(machCommands+offset);			offset+=genericCommand->cmdsize;			break;			}			case LC_FVMFILE:			{			WRITE_STRING("LC_FVMFILE\r{\r")			fvmFileCommand = (fvmfile_command*)(machCommands+offset);									WRITE_STRING("path: ")			for(k=0;((char*)fvmFileCommand+fvmFileCommand->name.offset)[k]!=0;k++){}			_WRITE(k,((char*)fvmFileCommand+fvmFileCommand->name.offset))			WRITE_STRING("\r")			WRITE_STRING("header_addr: 0x")			hex2char(fvmFileCommand->header_addr,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")						WRITE_STRING("}\r\r")			offset+=fvmFileCommand->cmdsize;			break;			}			case LC_PREPAGE:			{			WRITE_STRING("LC_PREPAGE\r\r")			genericCommand = (load_command*)(machCommands+offset);			offset+=genericCommand->cmdsize;			break;			}			case LC_DYSYMTAB:			{			WRITE_STRING("LC_DYSYMTAB\r{\r")			dySymTabCommand = (dysymtab_command*)(machCommands+offset);						NumberToString(dySymTabCommand->ilocalsym,number);			WRITE_STRING("ilocalsym: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nlocalsym,number);			WRITE_STRING("nlocalsym: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->iextdefsym,number);			WRITE_STRING("iextdefsym: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nextdefsym,number);			WRITE_STRING("nextdefsym: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->iundefsym,number);			WRITE_STRING("iundefsym: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nundefsym,number);			WRITE_STRING("nundefsym: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->tocoff,number);			WRITE_STRING("tocoff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->ntoc,number);			WRITE_STRING("ntoc: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->modtaboff,number);			WRITE_STRING("modtaboff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nmodtab,number);			WRITE_STRING("nmodtab: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->extrefsymoff,number);			WRITE_STRING("extrefsymoff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nextrefsyms,number);			WRITE_STRING("nextrefsyms: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->indirectsymoff,number);			WRITE_STRING("indirectsymoff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nindirectsyms,number);			WRITE_STRING("nindirectsyms: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->extreloff,number);			WRITE_STRING("extreloff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nextrel,number);			WRITE_STRING("nextrel: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->locreloff,number);			WRITE_STRING("locreloff: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(dySymTabCommand->nlocrel,number);			WRITE_STRING("nlocrel: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						WRITE_STRING("}\r\r")			offset+=dySymTabCommand->cmdsize;			break;			}			case LC_LOAD_DYLIB:			{			WRITE_STRING("LC_LOAD_DYLIB\r{\r")			dyLibCommand = (dylib_command*)(machCommands+offset);			WRITE_STRING("path:\t\t\t\t\t")			for(k=0;((char*)dyLibCommand+dyLibCommand->dylib.name.offset)[k]!=0;k++){}			_WRITE(k,((char*)dyLibCommand+dyLibCommand->dylib.name.offset))			WRITE_STRING("\r")			WRITE_STRING("timestamp:\t\t\t\t")			NumberToString(dyLibCommand->dylib.timestamp,number);			_WRITE(number[0],number+1)			WRITE_STRING("\r")			WRITE_STRING("current_version:\t\t0x")			hex2char(dyLibCommand->dylib.current_version,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")			WRITE_STRING("compatibility_version:\t0x")			hex2char(dyLibCommand->dylib.compatibility_version,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")			WRITE_STRING("}\r\r")			offset+=dyLibCommand->cmdsize;			break;			}			case LC_ID_DYLIB:			{			WRITE_STRING("LC_ID_DYLIB\r{\r")			dyLibCommand = (dylib_command*)(machCommands+offset);						WRITE_STRING("path:\t\t\t\t\t")			for(k=0;((char*)dyLibCommand+dyLibCommand->dylib.name.offset)[k]!=0;k++){}			_WRITE(k,((char*)dyLibCommand+dyLibCommand->dylib.name.offset))			WRITE_STRING("timestamp:\t\t\t\t")			NumberToString(dyLibCommand->dylib.timestamp,number);			_WRITE(number[0],number+1)			WRITE_STRING("\r")			WRITE_STRING("current_version:\t\t0x")			hex2char(dyLibCommand->dylib.current_version,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")			WRITE_STRING("compatibility_version:\t0x")			hex2char(dyLibCommand->dylib.compatibility_version,number);			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")			WRITE_STRING("}\r\r")						offset+=dyLibCommand->cmdsize;			break;			}			case LC_LOAD_DYLINKER:			{			WRITE_STRING("LC_LOAD_DYLINKER\r{\r")			dyLinkerCommand = (dylinker_command*)(machCommands+offset);						WRITE_STRING("path: ")			for(k=0;((char*)dyLinkerCommand+dyLinkerCommand->name.offset)[k]!=0;k++){}			_WRITE(k,((char*)dyLinkerCommand+dyLinkerCommand->name.offset))			WRITE_STRING("\r}\r\r")						offset+=dyLinkerCommand->cmdsize;			break;			}			case LC_ID_DYLINKER:			{			WRITE_STRING("LC_ID_DYLINKER\r{\r")			dyLinkerCommand = (dylinker_command*)(machCommands+offset);						WRITE_STRING("path: ")			for(k=0;((char*)dyLinkerCommand+dyLinkerCommand->name.offset)[k]!=0;k++){}			_WRITE(k,((char*)dyLinkerCommand+dyLinkerCommand->name.offset))			WRITE_STRING("\r}\r\r")						offset+=dyLinkerCommand->cmdsize;			break;			}			case LC_PREBOUND_DYLIB:			{			WRITE_STRING("LC_PREBOUND_DYLIB\r{\r")			preBoundDyLibCommand = (prebound_dylib_command*)(machCommands+offset);						WRITE_STRING("path: ")			for(k=0;((char*)preBoundDyLibCommand+preBoundDyLibCommand->name.offset)[k]!=0;k++){}			_WRITE(k,((char*)preBoundDyLibCommand+preBoundDyLibCommand->name.offset))			WRITE_STRING("\r")			WRITE_STRING("nmodules: ")			NumberToString(preBoundDyLibCommand->nmodules,number);			_WRITE(number[0],number+1)			/*			WRITE_STRING("\r")			for(i=0,k=0;i<preBoundDyLibCommand->nmodules;i++)			{			if(i>=32){k++;}			WRITE_STRING("module ")			NumberToString(i,number);			_WRITE(number[0],number+1)			WRITE_STRING(": ")						((char*)preBoundDyLibCommand+preBoundDyLibCommand->linked_modules.offset)[k];			}			*/												WRITE_STRING("\r}\r\r")			offset+=preBoundDyLibCommand->cmdsize;			break;			}			case LC_ROUTINES:			{			WRITE_STRING("LC_ROUTINES\r{\r")			routinesCommand = (routines_command*)(machCommands+offset);						hex2char(routinesCommand->init_address,number);			WRITE_STRING("init_address: 0x")			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")			hex2char(routinesCommand->init_module,number);			WRITE_STRING("init_module: 0x")			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")						WRITE_STRING("}\r\r")			offset+=genericCommand->cmdsize;			break;			}			case LC_SUB_FRAMEWORK:			{			WRITE_STRING("LC_SUB_FRAMEWORK\r{\r")			subFrameworkCommand = (sub_framework_command*)(machCommands+offset);						WRITE_STRING("umbrella: ")			for(k=0;((char*)subFrameworkCommand+subFrameworkCommand->umbrella.offset)[k]!=0;k++){}			_WRITE(k,((char*)subFrameworkCommand+subFrameworkCommand->umbrella.offset))			WRITE_STRING("\r}\r\r")			offset+=subFrameworkCommand->cmdsize;			break;			}			case LC_SUB_UMBRELLA:			{			WRITE_STRING("LC_SUB_UMBRELLA\r{\r")			subUmbrellaCommand = (sub_umbrella_command*)(machCommands+offset);						WRITE_STRING("sub_umbrella: ")			for(k=0;((char*)subUmbrellaCommand+subUmbrellaCommand->sub_umbrella.offset)[k]!=0;k++){}			_WRITE(k,((char*)subUmbrellaCommand+subUmbrellaCommand->sub_umbrella.offset))			WRITE_STRING("\r}\r\r")						offset+=subUmbrellaCommand->cmdsize;			break;			}			case LC_SUB_CLIENT:			{			WRITE_STRING("LC_SUB_CLIENT\r{\r")			subClientCommand = (sub_client_command*)(machCommands+offset);						WRITE_STRING("client: ")			for(k=0;((char*)subClientCommand+subClientCommand->client.offset)[k]!=0;k++){}			_WRITE(k,((char*)subClientCommand+subClientCommand->client.offset))			WRITE_STRING("\r}\r\r")						offset+=subClientCommand->cmdsize;			break;			}			case LC_SUB_LIBRARY:			{			WRITE_STRING("LC_SUB_LIBRARY\r\r")			subLibraryCommand = (sub_library_command*)(machCommands+offset);						WRITE_STRING("sub_library: ")			for(k=0;((char*)subLibraryCommand+subLibraryCommand->sub_library.offset)[k]!=0;k++){}			_WRITE(k,((char*)subLibraryCommand+subLibraryCommand->sub_library.offset))			WRITE_STRING("\r}\r\r")						offset+=subLibraryCommand->cmdsize;			break;			}			case LC_TWOLEVEL_HINTS:			{			WRITE_STRING("LC_TWOLEVEL_HINTS\r{\r")			twoLevelHintCommand = (twolevel_hints_command*)(machCommands+offset);						hints = (twolevel_hint*)NewPtr(sizeof(twolevel_hint)*twoLevelHintCommand->nhints);			if(!fatArch)			{SetFPos(appref,fsFromStart,twoLevelHintCommand->offset);}			else			{SetFPos(appref,fsFromStart,twoLevelHintCommand->offset+fatArchOffset);}			count = sizeof(twolevel_hint)*twoLevelHintCommand->nhints;			FSRead(appref,&count,hints);						NumberToString(twoLevelHintCommand->offset,number);			WRITE_STRING("offset: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r")						NumberToString(twoLevelHintCommand->nhints,number);			WRITE_STRING("nhints: ")			_WRITE(number[0],number+1)			WRITE_STRING("\r{")						for(i=0;i<twoLevelHintCommand->nhints;i++)			{			WRITE_STRING("\r")			WRITE_STRING("isub_image: ")			NumberToString(hints[i].isub_image,number);			_WRITE(number[0],number+1)			WRITE_STRING("\r")						WRITE_STRING("itoc: ")			NumberToString(hints[i].itoc,number);			_WRITE(number[0],number+1)			WRITE_STRING("\r")			}						WRITE_STRING("}\r}\r\r")			offset+=twoLevelHintCommand->cmdsize;			break;			}			case LC_PREBIND_CKSUM:			{			WRITE_STRING("LC_PREBIND_CKSUM\r{\r")			prebindCksumCommand = (prebind_cksum_command*)(machCommands+offset);						hex2char(prebindCksumCommand->cksum,number);			WRITE_STRING("cksum: 0x")			k=0;while(number[k]=='0'&&k<7){k++;}			_WRITE(8-k,number+k)			WRITE_STRING("\r")						WRITE_STRING("}\r\r")			offset+=prebindCksumCommand->cmdsize;			break;			}			case LC_LOAD_WEAK_DYLIB:			{			WRITE_STRING("LC_LOAD_WEAK_DYLIB\r")			dyLibCommand = (dylib_command*)(machCommands+offset);			WRITE_STRING("path: ")			for(k=0;((char*)dyLibCommand+dyLibCommand->dylib.name.offset)[k]!=0;k++){}			_WRITE(k,((char*)dyLibCommand+dyLibCommand->dylib.name.offset))			WRITE_STRING("\r}\r")												WRITE_STRING("\r")			offset+=dyLibCommand->cmdsize;			break;			}			default:			{			WRITE_STRING("UNKNOWN COMMAND\r\r")			genericCommand = (load_command*)(machCommands+offset);			offset+=genericCommand->cmdsize;			break;			}		}	}SetEOF(outInfoRef,totalWritten2);inData = NewPtr(totalWritten2);count = totalWritten2;SetFPos(outInfoRef,fsFromStart,0);FSRead(outInfoRef,&count,inData);SetFPos(outInfoRef,fsFromStart,0);totalData=totalWritten2;inPos=0;tabcount=0;totalWritten2=0;i=0;while(inPos<totalData){	while(inData[i]!='\r'){i++;}	if(inData[i-1]=='{'){tabcount++;}	else if(inData[i+1]=='}'){tabcount--;}	count = i-inPos+1;	FSWrite(outInfoRef,&count,inData+inPos);	totalWritten2 += count;	i++;	inPos=i;	WRITE_TAB(tabcount);		}DisposePtr(inData);SetEOF(outInfoRef,totalWritten2);FSClose(outInfoRef);}#ifdef __POWERPC__DisposePtr((char*)asmFile);DisposePtr((char*)infoFile);#endifif(hints){DisposePtr(hints);}if(stringTable){DisposePtr(stringTable);}if(symbolEntry){DisposePtr(symbolEntry);}if(fatArchHeader){DisposePtr(fatArchHeader);}if(machCommands){DisposePtr(machCommands);}if(codeSection){DisposePtr(codeSection);}if(symbolEntry){DisposePtr(symbolEntry);}if(stringTable){DisposePtr(stringTable);}FSClose(appref);}