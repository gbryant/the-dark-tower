Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define ASSIGN_KEY_FILTER(X,Y,Z)\controlOwner=X;\SetControlProperty(Z,kCreatorCode,kControlOwner,sizeof(long),&controlOwner);\controlType=Y;\SetControlProperty(Z,kCreatorCode,kControlType,sizeof(long),&controlType);\SetControlData(Z,kControlEditTextPart,kControlEditTextValidationProcTag,sizeof(ControlEditTextValidationUPP),&gEditTextValidaterUPP);\SetControlData(Z,kControlEditTextPart,kControlEditTextKeyFilterTag,sizeof(ControlKeyFilterUPP),&gEditTextKeyFilterUPP);pascal OSStatus SearchMenuHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData);#define DisassembleInstruction(X,Y)\mnPB.s = Y;\mnPB.i = X;\oldSetting = gGlobalSettings.labels;\oldSetting2 = gGlobalSettings.procs;\gGlobalSettings.labels=false;\gGlobalSettings.procs=false;\gCodeBrowserListing=true;\switch((mnPB.i&0xFC000000)>>26)\{\case 3:OP_03(&mnPB);break;\case 4:OP_04(&mnPB);break;\case 7:OP_07(&mnPB);break;\case 8:OP_08(&mnPB);break;\case 10:OP_10(&mnPB);break;\case 11:OP_11(&mnPB);break;\case 12:OP_12(&mnPB);break;\case 13:OP_13(&mnPB);break;\case 14:OP_14(&mnPB);break;\case 15:OP_15(&mnPB);break;\case 16:OP_16(&mnPB);break;\case 17:OP_17(&mnPB);break;\case 18:OP_18(&mnPB);break;\case 19:OP_19(&mnPB);break;\case 20:OP_20(&mnPB);break;\case 21:OP_21(&mnPB);break;\case 23:OP_23(&mnPB);break;\case 24:OP_24(&mnPB);break;\case 25:OP_25(&mnPB);break;\case 26:OP_26(&mnPB);break;\case 27:OP_27(&mnPB);break;\case 28:OP_28(&mnPB);break;\case 29:OP_29(&mnPB);break;\case 31:OP_31(&mnPB);break;\case 32:OP_32(&mnPB);break;\case 33:OP_33(&mnPB);break;\case 34:OP_34(&mnPB);break;\case 35:OP_35(&mnPB);break;\case 36:OP_36(&mnPB);break;\case 37:OP_37(&mnPB);break;\case 38:OP_38(&mnPB);break;\case 39:OP_39(&mnPB);break;\case 40:OP_40(&mnPB);break;\case 41:OP_41(&mnPB);break;\case 42:OP_42(&mnPB);break;\case 43:OP_43(&mnPB);break;\case 44:OP_44(&mnPB);break;\case 45:OP_45(&mnPB);break;\case 46:OP_46(&mnPB);break;\case 47:OP_47(&mnPB);break;\case 48:OP_48(&mnPB);break;\case 49:OP_49(&mnPB);break;\case 50:OP_50(&mnPB);break;\case 51:OP_51(&mnPB);break;\case 52:OP_52(&mnPB);break;\case 53:OP_53(&mnPB);break;\case 54:OP_54(&mnPB);break;\case 55:OP_55(&mnPB);break;\case 59:OP_59(&mnPB);break;\case 63:OP_63(&mnPB);break;\default:OP_DC(&mnPB);break;\}\gGlobalSettings.labels=oldSetting;\gGlobalSettings.procs=oldSetting2;\gCodeBrowserListing=false;WindowRef EditSource(FileReference	target){OSErr								err;IBNibRef							nibRef;Boolean								dirty;long								winType;WindowRef							tempWin;WindowRef							sourceWindow;long								controlOwner,controlType,arg;ControlID							controlID;EventHandlerUPP						controlHandlerUPP;EventTypeSpec						list[3];GrafPtr								port;DataView 							*srcDataView;DataViewColumn						**currColumn;long								rowCapacity,rowHeight;long								i;FontInfo							fontInfo;ControlRef							sourceBrowser,scrollBar,searchField,addressField;ControlRef 							searchMenu;EventHandlerUPP 					controlMenuHandlerUPP;MenuRef								menu;long								searchType;err = CreateNibReference(CFSTR("SourceEditor"), &nibRef);if(err){DebugFunction("\pError Creating Nib Reference: SourceEditor");}err = CreateWindowFromNib(nibRef, CFSTR("SourceEditor"), &sourceWindow);if(err){DebugFunction("\pError Creating Window: SourceEditor");}dirty = false;SetWindowProperty(sourceWindow,kCreatorCode,kWindowDirty,sizeof(Boolean),&dirty);winType = kSourceEditor;SetWindowProperty(sourceWindow,kCreatorCode,kWindowType,sizeof(long),&winType);err = CreateWindowFromNib(gSaveChangesNibRef, CFSTR("SaveChangesWindow"), &tempWin);if(err){DebugFunction("\pError Creating Window: SaveChangesWindow");}winType = kAskSave;SetWindowProperty(tempWin,kCreatorCode,kWindowType,sizeof(long),&winType);SetWindowProperty(sourceWindow,kCreatorCode,kSaveSheet,sizeof(WindowRef),&tempWin);arg=0;SetWindowProperty(sourceWindow,kCreatorCode,kFileReference,sizeof(FileReference*),&arg);list[0].eventClass=kEventClassWindow;list[0].eventKind=kEventWindowClose;InstallWindowEventHandler(sourceWindow,gWinCloseHandlerUPP,1,list,&sourceWindow,NULL); /*err = CreateNibReference(CFSTR("SourceEditor"), &nibRef);if(err){DebugFunction("\pError Creating Nib Reference: SourceEditor");}CreateMenuFromNib(nibRef,CFSTR("SourceOpcodes"),&gSourceInstructionMenu);DisposeNibReference(nibRef);*///-------------------------------------------DataView Code-------------------------------------------controlID.signature='src ';controlID.id=kSRC_SearchMenu;GetControlByID(sourceWindow,&controlID,&searchMenu);menu = GetControlPopupMenuHandle(searchMenu);SetItemMark(menu,3,diamondMark);searchType = kMnemonicSearch;SetControlProperty(searchMenu,kCreatorCode,kSearchType,sizeof(long),&searchType);controlMenuHandlerUPP = NewEventHandlerUPP(SearchMenuHandler);list[0].eventClass=kEventClassControl;list[0].eventKind=kEventControlClick;InstallControlEventHandler(searchMenu,controlMenuHandlerUPP,1,list,searchMenu,NULL);controlID.signature='src ';controlID.id=kSRC_HIView;GetControlByID(sourceWindow,&controlID,&sourceBrowser);controlID.signature='src ';controlID.id=kSRC_ScrollBar;GetControlByID(sourceWindow,&controlID,&scrollBar);controlID.signature='src ';controlID.id=kSRC_OffsetBox;GetControlByID(sourceWindow,&controlID,&addressField);controlID.signature='src ';controlID.id=kSRC_SearchBox;GetControlByID(sourceWindow,&controlID,&searchField);ASSIGN_KEY_FILTER(kSRC_Edit,kAddressField,addressField)ASSIGN_KEY_FILTER(kSRC_Edit,kSearchField,searchField)SetControlProperty(addressField,kCreatorCode,kSrcScrollBar,sizeof(ControlRef),&scrollBar);SetControlProperty(searchField,kCreatorCode,kSrcScrollBar,sizeof(ControlRef),&scrollBar);SetControlProperty(searchField,kCreatorCode,kSearchMenu,sizeof(ControlRef),&searchMenu);srcDataView=(DataView*)NewPtr(sizeof(DataView));SetWindowProperty(sourceWindow,kCreatorCode,kSrcDataView,sizeof(DataView*),&srcDataView);SetWindowProperty(sourceWindow,kCreatorCode,kSrcScrollBar,sizeof(ControlRef),&scrollBar);SetWindowProperty(sourceWindow,kCreatorCode,kSrcBrowser,sizeof(ControlRef),&sourceBrowser);SetWindowProperty(sourceWindow,kCreatorCode,kFileReference,sizeof(FileReference),&target);SetControlProperty(scrollBar,kCreatorCode,kSrcWindow,sizeof(WindowRef),&sourceWindow);GetControlBounds(sourceBrowser,&srcDataView->bounds);srcDataView->fontSize=12;MyPStrAdd("\p","\pMonaco",srcDataView->font);srcDataView->horizontalMargin=10;srcDataView->verticalMargin=2;srcDataView->columns=0;srcDataView->columnCount=0;srcDataView->rowData=0;srcDataView->rowCount=0;srcDataView->scrollPosition=0;long	codeSize;long	*codeSection;if(target){codeSection = ObtainSourceChain(target,&codeSize);if(codeSection&&codeSize){srcDataView->rowCount=codeSize/4;srcDataView->rowData=codeSection;}}GetPort(&port);SetPort(GetWindowPort(sourceWindow));TextFont(FMGetFontFamilyFromName(srcDataView->font));TextSize(srcDataView->fontSize);GetFontInfo(&fontInfo);rowHeight=fontInfo.ascent+fontInfo.descent+srcDataView->verticalMargin*2;rowCapacity=((srcDataView->bounds.bottom-srcDataView->bounds.top)/rowHeight);SetPort(port);/*for(i=0;i<50;i++){AddDataViewRow(srcDataView,i);}*/AddDataViewColumn("\pAddress",StringWidth("\p0xDDDDDDDD"),'addr',srcDataView,sourceWindow);AddDataViewColumn("\pMnemonic",StringWidth("\pddddddddd"),'mnem',srcDataView,sourceWindow);AddDataViewColumn("\pArguments",StringWidth("\pfr33,fr33,fr33,fr33"),'args',srcDataView,sourceWindow);AddDataViewColumn("\pHexadecimal",StringWidth("\p0xDDDDDDDD"),'hexa',srcDataView,sourceWindow);SetControl32BitMinimum(scrollBar,0);SetControl32BitValue(scrollBar,0);SetControl32BitMaximum(scrollBar,srcDataView->rowCount-rowCapacity);controlHandlerUPP = NewEventHandlerUPP(SrcViewDrawHandler);list[0].eventClass=kEventClassControl;list[0].eventKind=kEventControlDraw;InstallControlEventHandler(sourceBrowser,controlHandlerUPP,1,list,sourceWindow,NULL);/*controlHandlerUPP = NewEventHandlerUPP(SrcViewClickHandler);list[0].eventClass=kEventClassControl;list[0].eventKind=kEventControlClick;InstallControlEventHandler(gAppControls.srcBrowser,controlHandlerUPP,1,list,srcDataView,NULL);*/ControlActionUPP scrollProcUPP;scrollProcUPP = NewControlActionUPP(SrcScrollProcedure);SetControlAction(scrollBar,scrollProcUPP);/*controlHandlerUPP = NewEventHandlerUPP(AppControlHandler);list[0].eventClass=kEventClassControl;list[0].eventKind=kEventControlClick;InstallControlEventHandler(gAppControls.srcScrollBar,controlHandlerUPP,1,list,srcDataView,NULL);*///-------------------------------------------DataView Code-------------------------------------------ShowWindow(sourceWindow);gSourceEditorWindows++;return sourceWindow;}pascal OSStatus SrcViewClickHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){Point					point;long					i,j;DataViewColumn			*currColumn;Rect					rect,clipRect,scrollBarBounds;GrafPtr					port;long					delta;DataView 				*srcDataView;long 					rowHeight;long 					rowCapacity;FontInfo				fontInfo;RgnHandle				savedClip;char					string[11];MnemonicPBlock			mnPB;bool					oldSetting,oldSetting2,match;ControlRef				scrollBar;GetWindowProperty((WindowRef)userData,kCreatorCode,kSrcDataView,sizeof(DataView*),0,&srcDataView);GetWindowProperty((WindowRef)userData,kCreatorCode,kSrcScrollBar,sizeof(ControlRef),0,&scrollBar);GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof(Point), NULL, &point);SetRect(&rect,srcDataView->bounds.left,srcDataView->bounds.top,srcDataView->bounds.right,srcDataView->bounds.bottom);GetPort(&port);SetPort(GetWindowPort((WindowRef)userData));GlobalToLocal(&point);currColumn = srcDataView->columns;GetFontInfo(&fontInfo);rowHeight=fontInfo.ascent+fontInfo.descent+srcDataView->verticalMargin*2;rowCapacity=((srcDataView->bounds.bottom-srcDataView->bounds.top)/rowHeight);savedClip = NewRgn();GetClip(savedClip);GetControlBounds(scrollBar,&scrollBarBounds);SetRect(&clipRect,srcDataView->bounds.left+1,srcDataView->bounds.top+1+1+rowHeight,srcDataView->bounds.right-1-(scrollBarBounds.right-scrollBarBounds.left),srcDataView->bounds.bottom-1);SetRect(&rect,srcDataView->bounds.left+1,srcDataView->bounds.top+1+1+rowHeight,srcDataView->bounds.right-1,srcDataView->bounds.top+1+1+rowHeight*2);//point.h-=srcDataView->bounds.left;point.v-=srcDataView->bounds.top;ClipRect(&clipRect);if(point.v>rowHeight){	currColumn = srcDataView->columns;	match=false;	for(i=0;i<srcDataView->columnCount;i++)	{		if(point.h<currColumn->right&&point.h>currColumn->left){match=true;break;}		currColumn = currColumn->next;	}	if(match)	{		OffsetRect(&rect,0,rowHeight*((point.v/rowHeight)-1));		rect.left=currColumn->left+1;		rect.right=currColumn->right;		FrameRect(&rect);		switch(currColumn->type)		{		case 'hexa':					hex2char(srcDataView->rowData[srcDataView->scrollPosition+((point.v/rowHeight)-1)],string+3);					string[0]=10;string[1]='0';string[2]='x';										short pixelWidth;										pixelWidth = TextWidth(string+1,0,string[0]);															if(pixelWidth){SysBeep(1);}										long *charWidths;					charWidths = (long*)NewPtrClear((string[0]+2)*sizeof(long));					MeasureText(string[0]*2,string+1,charWidths);					if(charWidths[2]){SysBeep(1);}					DisposePtr((char*)charWidths);										short byteOffset;					Point numer;					Point denom;					unsigned char leadingEdge;					long widthRemaining;										numer.h=1;numer.v=1;					denom.h=1;denom.v=1;										byteOffset = CharToPixel(string+1,string[0],0,2,hilite,onlyStyleRun,numer,denom);					if(byteOffset){SysBeep(1);}					byteOffset = PixelToChar(string+1,string[0],0,14,&leadingEdge,&widthRemaining,onlyStyleRun,numer,denom);					if(widthRemaining>0)					{if(byteOffset){SysBeep(1);}}					Debugger();					break;		}	}}SetClip(savedClip);SetPort(port);return noErr;}pascal OSStatus SrcViewDrawHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){GrafPtr					port,savedPort;Rect					rect;long					err;FontInfo				fontInfo;long					headerCount,headerFontSize,headerVerticalMargin;long					i,j,k,n;Str255					headers[10];long					h,v;DataViewColumn			*currColumn;RGBColor				rgbColor;long 					rowHeight;long 					rowCapacity;MnemonicPBlock			mnPB;bool 					oldSetting,oldSetting2;DataView				*srcDataView;GetWindowProperty((WindowRef)userData,kCreatorCode,kSrcDataView,sizeof(DataView*),0,&srcDataView);//-------------------------------------Port Setting Stuff-------------------------------------err=GetEventParameter(theEvent, kEventParamGrafPort, typeGrafPtr, NULL, sizeof(GrafPtr), NULL, &port);GetPort(&savedPort);if(err){SetPort(GetWindowPort((WindowRef)userData));}else{SetPort(port);}//-------------------------------------Port Setting Stuff-------------------------------------TextFont(FMGetFontFamilyFromName(srcDataView->font));TextSize(srcDataView->fontSize);GetFontInfo(&fontInfo);//HideControl(gAppControls.srcScrollBar);//-------------------------------------Row Drawing-------------------------------------ClipRect(&srcDataView->bounds);rowHeight=fontInfo.ascent+fontInfo.descent+srcDataView->verticalMargin*2;rowCapacity=((srcDataView->bounds.bottom-srcDataView->bounds.top)/rowHeight);for(i=0;i<rowCapacity;i+=2){rgbColor.red	=	181*257;rgbColor.green	=	213*257;rgbColor.blue	=	255*257;RGBForeColor(&rgbColor);SetRect(&rect,srcDataView->bounds.left+1,srcDataView->bounds.top+1+1+rowHeight,srcDataView->bounds.right-1,srcDataView->bounds.top+1+1+rowHeight*2);OffsetRect(&rect,0,rowHeight*i);PaintRect(&rect);rgbColor.red	=	255*257;rgbColor.green	=	255*257;rgbColor.blue	=	255*257;RGBForeColor(&rgbColor);SetRect(&rect,srcDataView->bounds.left+1,srcDataView->bounds.top+1+1+rowHeight,srcDataView->bounds.right-1,srcDataView->bounds.top+1+1+rowHeight*2);OffsetRect(&rect,0,rowHeight*(i+1));PaintRect(&rect);}rgbColor.red	=	0*257;rgbColor.green	=	0*257;rgbColor.blue	=	0*257;RGBForeColor(&rgbColor);char string[11];currColumn = srcDataView->columns;for(i=0;i<srcDataView->columnCount;i++){	switch(currColumn->type)	{		case 'addr':		for(j=1;j<=(srcDataView->rowCount>rowCapacity?rowCapacity:srcDataView->rowCount);j++)		{		hex2char((j-1)*4,string+3);		string[0]=10;string[1]='0';string[2]='x';		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)string);		}		break;		case 'hexa':		for(j=1;j<=(srcDataView->rowCount>rowCapacity?rowCapacity:srcDataView->rowCount);j++)		{		hex2char(srcDataView->rowData[j-1],string+3);		string[0]=10;string[1]='0';string[2]='x';		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)string);		}		break;		case 'mnem':		for(j=1;j<=(srcDataView->rowCount>rowCapacity?rowCapacity:srcDataView->rowCount);j++)		{		bm     = 0;		buffer = NewPtr(200);		buffer++;		DisassembleInstruction(srcDataView->rowData[j-1],(j-1))		k=0;while(buffer[k]!='\r'&&buffer[k]!='\t'&&buffer[k]!=' '){k++;}		buffer--;		buffer[0]=k;		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)buffer);		DisposePtr(buffer);		}		break;		case 'args':		for(j=1;j<=(srcDataView->rowCount>rowCapacity?rowCapacity:srcDataView->rowCount);j++)		{		bm     = 0;		buffer = NewPtr(200);		DisassembleInstruction(srcDataView->rowData[j-1],(j-1))		k=0;while(buffer[k]!='\r'&&buffer[k]!='\t'&&buffer[k]!=' '){k++;}		if(buffer[k]!='\r')		{		while(buffer[k]==' '||buffer[k]=='\t'){k++;}		n=k;		while(buffer[k]!='\r'){k++;}		buffer[n-1]=k-n;		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)buffer+(n-1));		}		DisposePtr(buffer);		}		break;			}currColumn = currColumn->next;}//-------------------------------------Row Drawing-------------------------------------//-------------------------------------Column Drawing-------------------------------------FrameRect(&srcDataView->bounds);MoveTo(srcDataView->bounds.left+1,srcDataView->bounds.top+1+fontInfo.ascent+fontInfo.descent+srcDataView->verticalMargin*2);Line(srcDataView->bounds.right-srcDataView->bounds.left,0);currColumn = srcDataView->columns;for(i=0;i<srcDataView->columnCount;i++){MoveTo(currColumn->right,srcDataView->bounds.top);Line(0,srcDataView->bounds.bottom-srcDataView->bounds.top-1);MoveTo(currColumn->left+(currColumn->width/2)-(StringWidth(currColumn->title)/2),srcDataView->bounds.top+fontInfo.ascent+srcDataView->verticalMargin);DrawString(currColumn->title);currColumn = currColumn->next;}//-------------------------------------Column Drawing-------------------------------------//-------------------------------------Port Setting Stuff-------------------------------------if(!port){SetPort(savedPort);}//-------------------------------------Port Setting Stuff-------------------------------------return noErr;}void AddDataViewColumn(Str255 title, long width, long type, DataView *dataView,WindowRef window){DataViewColumn				**currColumn;DataViewColumn				*prevColumn;GrafPtr						port,savedPort;GetPort(&savedPort);SetPort(GetWindowPort(window));TextSize(dataView->fontSize);currColumn = &dataView->columns;prevColumn = *currColumn;while((*currColumn)){prevColumn = *currColumn;currColumn = &(*currColumn)->next;}(*currColumn) = (DataViewColumn*)NewPtr(sizeof(DataViewColumn));MyPStrAdd(title,"\p",(*currColumn)->title);(*currColumn)->type=type;if(width>=StringWidth(title)){(*currColumn)->width = width+(dataView->horizontalMargin*2);}else{(*currColumn)->width = StringWidth(title)+(dataView->horizontalMargin*2);}(*currColumn)->next=0;dataView->columnCount++;//StringWidth(title)if(!prevColumn){(*currColumn)->left = dataView->bounds.left;(*currColumn)->right = dataView->bounds.left+width+(dataView->horizontalMargin*2);}else{(*currColumn)->left = prevColumn->right;(*currColumn)->right = prevColumn->right+width+(dataView->horizontalMargin*2);}SetPort(savedPort);}pascal void SrcScrollProcedure(ControlHandle theControl, short part){RgnHandle				updateRegion;GrafPtr					savedPort;DataView 				*srcDataView;long					controlDelta;Rect					scrollRect;RgnHandle				savedClip;DataViewColumn			*currColumn;FontInfo				fontInfo;long					i,j,k,n,controlMax;RGBColor				evenColor,oddColor,rgbColor;long 					rowHeight;long 					rowCapacity;long					scrollAmount;Rect					rect,clipRect;Rect					scrollBarBounds;char					string[11];MnemonicPBlock			mnPB;bool					oldSetting,oldSetting2;WindowRef				window;savedClip = NewRgn();GetClip(savedClip);GetControlProperty(theControl,kCreatorCode,kSrcWindow,sizeof(WindowRef),0,&window);GetWindowProperty(window,kCreatorCode,kSrcDataView,sizeof(DataView*),0,&srcDataView);controlMax = GetControl32BitMaximum(theControl);GetPort(&savedPort);SetPort(GetWindowPort(window));updateRegion = NewRgn();evenColor.red	=	181*257;evenColor.green	=	213*257;evenColor.blue	=	255*257;oddColor.red	=	255*257;oddColor.green	=	255*257;oddColor.blue	=	255*257;rgbColor.red	=	0*257;rgbColor.green	=	0*257;rgbColor.blue	=	0*257;GetFontInfo(&fontInfo);rowHeight=fontInfo.ascent+fontInfo.descent+srcDataView->verticalMargin*2;rowCapacity=((srcDataView->bounds.bottom-srcDataView->bounds.top)/rowHeight);GetControlBounds(theControl,&scrollBarBounds);SetRect(&scrollRect,srcDataView->bounds.left+1,srcDataView->bounds.top+rowHeight+1+1,srcDataView->bounds.right-1-(scrollBarBounds.right-scrollBarBounds.left),srcDataView->bounds.bottom-1);scrollAmount=0;switch(part){	case kControlUpButtonPart:	{		if(srcDataView->scrollPosition>=1)		{		srcDataView->scrollPosition--;		scrollAmount=1;		SetControl32BitValue(theControl,srcDataView->scrollPosition);		}	break;	}	case kControlDownButtonPart:	{		if(srcDataView->scrollPosition<controlMax)		{		srcDataView->scrollPosition++;		scrollAmount=-1;		SetControl32BitValue(theControl,srcDataView->scrollPosition);		}	break;	}	case kControlPageUpPart:	{		if(srcDataView->scrollPosition>=5)		{		srcDataView->scrollPosition-=5;		scrollAmount=5;		SetControl32BitValue(theControl,srcDataView->scrollPosition);		}		else		{		scrollAmount=srcDataView->scrollPosition;		srcDataView->scrollPosition=0;		SetControl32BitValue(theControl,srcDataView->scrollPosition);		}	break;	}	case kControlPageDownPart:	{		if(srcDataView->scrollPosition<=(controlMax-5))		{		srcDataView->scrollPosition+=5;		scrollAmount=-5;		SetControl32BitValue(theControl,srcDataView->scrollPosition);		}		else		{		scrollAmount=srcDataView->scrollPosition-controlMax;		srcDataView->scrollPosition=controlMax;		SetControl32BitValue(theControl,srcDataView->scrollPosition);		}	break;	}	default:	case kControlIndicatorPart:	{		controlDelta = GetControl32BitValue(theControl) - srcDataView->scrollPosition;		scrollAmount = -controlDelta;		if(scrollAmount>0)		{		if(scrollAmount>rowCapacity)		{scrollAmount=rowCapacity;}		}		else if(scrollAmount<0)		{		if(-scrollAmount>rowCapacity)		{scrollAmount=-rowCapacity;}		}		srcDataView->scrollPosition = GetControl32BitValue(theControl);	break;	}}ScrollRect(&scrollRect, 0, scrollAmount*rowHeight,updateRegion);SetRect(&clipRect,srcDataView->bounds.left+1,srcDataView->bounds.top+1+1+rowHeight,srcDataView->bounds.right-1-(scrollBarBounds.right-scrollBarBounds.left),srcDataView->bounds.bottom-1);ClipRect(&clipRect);if(scrollAmount>0)//scroll up{	SetRect(&rect,srcDataView->bounds.left+1,srcDataView->bounds.top+1+1+rowHeight,srcDataView->bounds.right-1,srcDataView->bounds.top+1+1+rowHeight*2);	if(!(srcDataView->scrollPosition%2))	{		for(i=0;i<scrollAmount;i++)		{		if(i%2){RGBForeColor(&oddColor);}else{RGBForeColor(&evenColor);}		PaintRect(&rect);		OffsetRect(&rect,0,rowHeight);		}	}	else	{		for(i=0;i<scrollAmount;i++)		{		if(i%2){RGBForeColor(&evenColor);}else{RGBForeColor(&oddColor);}		PaintRect(&rect);		OffsetRect(&rect,0,rowHeight);		}	}	//-------------------------------------------Row Data Drawing--------------------------------------------	RGBForeColor(&rgbColor);	currColumn = srcDataView->columns;	for(i=0;i<srcDataView->columnCount;i++)	{		switch(currColumn->type)		{		case 'addr':		for(j=1;j<=scrollAmount;j++)		{		hex2char((srcDataView->scrollPosition+(j-1))*4,string+3);		string[0]=10;string[1]='0';string[2]='x';		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)string);		}		break;		case 'hexa':		for(j=1;j<=scrollAmount;j++)		{		hex2char(srcDataView->rowData[srcDataView->scrollPosition+(j-1)],string+3);		string[0]=10;string[1]='0';string[2]='x';		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)string);		}		break;		case 'mnem':		for(j=1;j<=scrollAmount;j++)		{		bm     = 0;		buffer = NewPtr(200);		buffer++;		DisassembleInstruction(srcDataView->rowData[srcDataView->scrollPosition+(j-1)],(srcDataView->scrollPosition+(j-1)))		k=0;while(buffer[k]!='\r'&&buffer[k]!='\t'&&buffer[k]!=' '){k++;}		buffer--;		buffer[0]=k;		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)buffer);		DisposePtr(buffer);		}		break;		case 'args':		for(j=1;j<=scrollAmount;j++)		{		bm     = 0;		buffer = NewPtr(200);		DisassembleInstruction(srcDataView->rowData[srcDataView->scrollPosition+(j-1)],(srcDataView->scrollPosition+(j-1)))		k=0;while(buffer[k]!='\r'&&buffer[k]!='\t'&&buffer[k]!=' '){k++;}		if(buffer[k]!='\r')		{		while(buffer[k]==' '||buffer[k]=='\t'){k++;}		n=k;		while(buffer[k]!='\r'){k++;}		buffer[n-1]=k-n;		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*j)+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)buffer+(n-1));		}		DisposePtr(buffer);		}		break;		}	currColumn = currColumn->next;	}	//-------------------------------------------Row Data Drawing--------------------------------------------}else if(scrollAmount<0)//scroll down{	SetRect(&rect,srcDataView->bounds.left+1,srcDataView->bounds.top+1+1+rowHeight,srcDataView->bounds.right-1,srcDataView->bounds.top+1+1+rowHeight*2);	OffsetRect(&rect,0,rowHeight*(rowCapacity-1));	OffsetRect(&rect,0,rowHeight*scrollAmount);	if((rowCapacity+srcDataView->scrollPosition-(-scrollAmount))%2)	{		for(i=0;i<-scrollAmount+1;i++)		{		if(i%2){RGBForeColor(&oddColor);}else{RGBForeColor(&evenColor);}		PaintRect(&rect);		OffsetRect(&rect,0,rowHeight);		}	}	else	{		for(i=0;i<-scrollAmount+1;i++)		{		if(i%2){RGBForeColor(&evenColor);}else{RGBForeColor(&oddColor);}		PaintRect(&rect);		OffsetRect(&rect,0,rowHeight);		}	}	//-------------------------------------------Row Data Drawing--------------------------------------------	RGBForeColor(&rgbColor);	currColumn = srcDataView->columns;	for(i=0;i<srcDataView->columnCount;i++)	{		switch(currColumn->type)		{		case 'addr':		for(j=-scrollAmount+1;j>0;j--)		{		hex2char((rowCapacity+srcDataView->scrollPosition-j)*4,string+3);		string[0]=10;string[1]='0';string[2]='x';		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*(rowCapacity-(j-1)))+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)string);		}		break;		case 'hexa':		for(j=-scrollAmount+1;j>0;j--)		{		hex2char(srcDataView->rowData[rowCapacity+srcDataView->scrollPosition-j],string+3);		string[0]=10;string[1]='0';string[2]='x';		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*(rowCapacity-(j-1)))+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)string);		}		break;		case 'mnem':		for(j=-scrollAmount+1;j>0;j--)		{		bm     = 0;		buffer = NewPtr(200);		buffer++;		DisassembleInstruction(srcDataView->rowData[rowCapacity+srcDataView->scrollPosition-j],(rowCapacity+srcDataView->scrollPosition-j))		k=0;while(buffer[k]!='\r'&&buffer[k]!='\t'&&buffer[k]!=' '){k++;}		buffer--;		buffer[0]=k;		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*(rowCapacity-(j-1)))+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)buffer);		DisposePtr(buffer);		}		break;		case 'args':		for(j=-scrollAmount+1;j>0;j--)		{		bm     = 0;		buffer = NewPtr(200);		DisassembleInstruction(srcDataView->rowData[rowCapacity+srcDataView->scrollPosition-j],(rowCapacity+srcDataView->scrollPosition-j))		k=0;while(buffer[k]!='\r'&&buffer[k]!='\t'&&buffer[k]!=' '){k++;}		if(buffer[k]!='\r')		{		while(buffer[k]==' '||buffer[k]=='\t'){k++;}		n=k;		while(buffer[k]!='\r'){k++;}		buffer[n-1]=k-n;		MoveTo(currColumn->left+5,srcDataView->bounds.top+1+1+(rowHeight*(rowCapacity-(j-1)))+fontInfo.ascent+srcDataView->verticalMargin);		DrawString((unsigned char*)buffer+(n-1));		}		DisposePtr(buffer);		}		break;		}	currColumn = currColumn->next;	}	//-------------------------------------------Row Data Drawing--------------------------------------------}//-----------------------------------------------------------------------currColumn = srcDataView->columns;for(i=0;i<srcDataView->columnCount;i++){MoveTo(currColumn->right,srcDataView->bounds.top);Line(0,srcDataView->bounds.bottom-srcDataView->bounds.top-1);currColumn = currColumn->next;}//-----------------------------------------------------------------------SetClip(savedClip);//InvalRgn(updateRegion);DisposeRgn(updateRegion);DisposeRgn(savedClip);SetPort(savedPort);}pascal OSStatus SearchMenuHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void* userData){Point			point;long			selection;MenuRef			menu;long			searchType;//GetControlProperty((ControlRef)userData,kCreatorCode,kSearchType,sizeof(long),0,&searchType);menu = GetControlPopupMenuHandle((ControlRef)userData);GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof(Point), NULL, &point);selection = PopUpMenuSelect(menu,point.v,point.h,0);if(selection>=3&&selection<=5){SetItemMark(menu,3,noMark);SetItemMark(menu,4,noMark);SetItemMark(menu,5,noMark);SetItemMark(menu,selection,diamondMark);SetControlProperty((ControlRef)userData,kCreatorCode,kSearchType,sizeof(long),&selection);}return noErr;}