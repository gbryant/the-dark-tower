Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"#define INCREMENT_CODE(X)												\X++;																	\if(X==asmPB->codeOutSize)												\{																		\asmPB->cCount = (asmPB->codeOutSize*sizeof(long));						\FSWrite(asmPB->codeOutRef,&asmPB->cCount,asmPB->asmRecord->insts);		\asmPB->asmRecord->instaccum+=asmPB->asmRecord->instcount;				\X=0;																	\}#define HANDLE_ARG_ERROR																				\FileRef_GetFileName(asmPB->currSrc,gTempTxt);															\MyPStrAdd("\pAn argument to an instruction was too large\rSource: ",gTempTxt,gTempTxt2);				\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																\NumberToString(asmPB->lineNum,(char*)gTempTxt3);														\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																\DebugFunction(gTempTxt2);#define HANDLE_MV_ERROR																					\FileRef_GetFileName(asmPB->currSrc,gTempTxt);															\MyPStrAdd("\pMissing a variable definition\rSource: ",gTempTxt,gTempTxt2);								\MyPStrAdd(gTempTxt2,"\p\rLine: ",gTempTxt);																\NumberToString(asmPB->lineNum,(char*)gTempTxt3);														\MyPStrAdd(gTempTxt,gTempTxt3,gTempTxt2);																\DebugFunction(gTempTxt2);#define _pow(A,B)							\for(g_powi=0,g_powrv=1;g_powi<B;g_powi++)	\{											\g_powrv*=A;									\}//#pragma optimization_level 0#define GetHexByte(X,Y)						\										\arg = 0;								\if(X[(Y)]>=0x30&&X[Y]<=0x39)		\{														\//arg += ((X[Y]-0x30)*(_pow(0x10,1)));					\arg += ((X[Y]-0x30)*(0x10));					\}														\else if(X[(Y)]>=0x41&&X[Y]<=0x46)					\{														\//arg += ((X[Y]-0x37)*(_pow(0x10,1)));					\arg += ((X[Y]-0x30)*(0x10));					\}														\else													\{														\//arg += ((X[Y]-0x57)*(_pow(0x10,1)));					\arg += ((X[Y]-0x30)*(0x10));					\}														\Y++;													\if(X[(Y)]>=0x30&&X[Y]<=0x39)						\{														\arg += ((X[Y]-0x30)*(_pow(0x10,0)));					\}														\else if(X[(Y)]>=0x41&&X[i]<=0x46)					\{														\//arg += ((X[Y]-0x37)*(_pow(0x10,0)));					\arg += ((X[Y]-0x30)*(1));					\}														\else													\{														\//arg += ((X[Y]-0x57)*(_pow(0x10,0)));					\arg += ((X[Y]-0x30)*(1));					\}														\Y++;#define GET_REGISTER																										\																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\if(arg>0x1F)																												\{																															\HANDLE_ARG_ERROR																											\}#define GET_CRF																												\																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																						\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));														\}																															\if(arg>0x07)																												\{																															\HANDLE_ARG_ERROR																											\}#define GET_SR																												\																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																						\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));														\}																															\if(arg>0x0F)																												\{																															\HANDLE_ARG_ERROR																											\}#define GET_BYTE																											\																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																						\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));														\}																															\if(arg>0xFF)																												\{																															\HANDLE_ARG_ERROR																											\}#define GET_10BIT																											\																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\if(arg>0x3FF)																												\{																															\HANDLE_ARG_ERROR																											\}#define GET_8BIT																											\																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\if(arg>0xFF)																												\{																															\HANDLE_ARG_ERROR																											\}#define GET_UIMM_16 GET_SIMM_16#define GET_SIMM_16																											\																															\neg=false;hex=false;off=false;txt=false;																					\_FindNumeric2(asmPB->lineAsmBuffer,asmPB->lineAsmBMark)																			\if(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39))								\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='-'){neg=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='$'){hex=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='*'){off=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='\''){txt=true;asmPB->lineAsmBMark++;}												\}bmHolder = asmPB->lineAsmBMark;																								\if(!hex && !off && !txt)																									\{																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\																															\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\}																															\else if(hex)																												\{																															\while(!((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F'))){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																																														\while((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F')){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)									\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\else																														\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x37)*(g_powrv));																\}																															\}																															\}																															\else if(off)																												\{																															\	while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]!=0x0D && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]!='('){asmPB->lineAsmBMark++;}			\	j = asmPB->lineAsmBMark-bmHolder;																								\	asmPB->lineAsmBMark = bmHolder;																								\	asmPB->name = NewPtr(j+1);																									\	for(bmHolder=0;bmHolder<j;bmHolder++,asmPB->lineAsmBMark++)																	\	{asmPB->name[bmHolder] = asmPB->lineAsmBuffer[asmPB->lineAsmBMark];}																\	asmPB->name[bmHolder]=0;																									\	asmPB->curr = asmPB->dataV;																									\	while(asmPB->curr)																											\	{																															\	tbv=MyCStrCmp(asmPB->name,asmPB->curr->name);																				\	if(tbv){break;}																												\	asmPB->curr = asmPB->curr->next;																							\	}																															\	if(tbv){arg=asmPB->curr->off;}																								\	else																														\	{																															\	HANDLE_MV_ERROR																												\	}																															\	DisposePtr(asmPB->name);																									\}																																\else if(txt)																													\{																																\arg=0;																															\arg+=(asmPB->lineAsmBuffer[asmPB->lineAsmBMark])<<8;asmPB->lineAsmBMark++;														\arg+=asmPB->lineAsmBuffer[asmPB->lineAsmBMark];asmPB->lineAsmBMark+=2;															\}																																\if(arg>0xFFFF)																													\{																																\HANDLE_ARG_ERROR																												\}																																\if(neg)																															\{																																\arg*=-1;																														\}																																\arg = arg & 0xFFFF;#define GET_DESTINATION_24																									\																															\neg=false;hex=false;label=false;																							\_FindNumeric2(asmPB->lineAsmBuffer,asmPB->lineAsmBMark)																			\if(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39))								\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='-'){neg=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='$'){hex=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='*'){label=true;asmPB->lineAsmBMark++;}												\}bmHolder = asmPB->lineAsmBMark;																								\if(!hex && !label)																											\{																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\																															\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\}																															\else if(hex && !label)																										\{																															\while(!((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F'))){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																																														\while((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F')){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)									\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\else																														\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x37)*(g_powrv));																\}																															\}																															\}																															\else																														\{																															\gTotalBranchCount++;\*asmPB->currBranch = (BranchEntry*)NewPtr(sizeof(BranchEntry));																\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]!=0x0D){asmPB->lineAsmBMark++;}														\j = asmPB->lineAsmBMark-bmHolder;																								\asmPB->lineAsmBMark = bmHolder;																								\(*asmPB->currBranch)->name = NewPtr(j+1);																					\(*asmPB->currBranch)->name[0] = j;																							\for(bmHolder=1;bmHolder<=j;bmHolder++,asmPB->lineAsmBMark++)																	\{																															\(*asmPB->currBranch)->name[bmHolder] = asmPB->lineAsmBuffer[asmPB->lineAsmBMark];													\}																															\(*asmPB->currBranch)->location = asmPB->asmRecord->instcount+asmPB->asmRecord->instaccum;																\(*asmPB->currBranch)->mask = 0xFFFFFF;																						\(*asmPB->currBranch)->next = nil;																							\asmPB->currBranch = &((*asmPB->currBranch)->next);																			\arg=0;																														\}																															\if(arg>0xFFFFFF)																											\{																															\HANDLE_ARG_ERROR																											\}																															\if(neg)																														\{																															\arg*=-1;																													\}																															\arg = arg & 0xFFFFFF;#define GET_DESTINATION_14																									\																															\neg=false;hex=false;label=false;																							\_FindNumeric2(asmPB->lineAsmBuffer,asmPB->lineAsmBMark)																			\if(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39))								\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='-'){neg=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='$'){hex=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='*'){label=true;asmPB->lineAsmBMark++;}												\}bmHolder = asmPB->lineAsmBMark;																								\if(!hex && !label)																											\{																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\																															\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\}																															\else if(hex && !label)																										\{																															\while(!((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F'))){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																																														\while((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F')){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)									\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\else																														\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x37)*(g_powrv));																\}																															\}																															\}																															\else																														\{																															\gTotalBranchCount++;\*asmPB->currBranch = (BranchEntry*)NewPtr(sizeof(BranchEntry));																\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]!=0x0D){asmPB->lineAsmBMark++;}														\j = asmPB->lineAsmBMark-bmHolder;																								\asmPB->lineAsmBMark = bmHolder;																								\(*asmPB->currBranch)->name = NewPtr(j+1);																					\(*asmPB->currBranch)->name[0] = j;																							\for(bmHolder=1;bmHolder<=j;bmHolder++,asmPB->lineAsmBMark++)																	\{																															\(*asmPB->currBranch)->name[bmHolder] = asmPB->lineAsmBuffer[asmPB->lineAsmBMark];													\}																															\(*asmPB->currBranch)->location = asmPB->asmRecord->instcount+asmPB->asmRecord->instaccum;																\(*asmPB->currBranch)->mask = 0x3FFF;																						\(*asmPB->currBranch)->next = nil;																							\asmPB->currBranch = &((*asmPB->currBranch)->next);																			\arg=0;																														\}																															\if(arg>0x3FFF)																												\{																															\HANDLE_ARG_ERROR																											\}																															\if(neg)																														\{																															\arg*=-1;																													\}																															\arg = arg & 0x3FFF;#define GET_32BIT																											\																															\txt=false;neg=false;hex=false;																								\_FindNumeric2(asmPB->lineAsmBuffer,asmPB->lineAsmBMark)																			\if(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39))								\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='-'){neg=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='$'){hex=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='\''){txt=true;asmPB->lineAsmBMark++;}												\}bmHolder = asmPB->lineAsmBMark;																								\if(!hex && !txt)																											\{																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\																															\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\}																															\else if(hex && !txt)																										\{																															\while(!((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F'))){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																																														\while((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F')){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)									\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\else																														\{																															\_pow(0x10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x37)*(g_powrv));																\}																															\}																															\}																															\else																														\{																															\arg=0;																														\arg+=(asmPB->lineAsmBuffer[asmPB->lineAsmBMark])<<24;asmPB->lineAsmBMark++;															\arg+=(asmPB->lineAsmBuffer[asmPB->lineAsmBMark])<<16;asmPB->lineAsmBMark++;															\arg+=(asmPB->lineAsmBuffer[asmPB->lineAsmBMark])<<8;asmPB->lineAsmBMark++;															\arg+=asmPB->lineAsmBuffer[asmPB->lineAsmBMark];asmPB->lineAsmBMark+=2;																\}																															\if(neg)																														\{																															\arg*=-1;																													\}																															#define GET_CRM																												\																															\neg=false;hex=false;																										\_FindNumeric(asmPB->lineAsmBuffer,asmPB->lineAsmBMark)																			\if(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39))								\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='-'){neg=true;asmPB->lineAsmBMark++;}													\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='$'){hex=true;asmPB->lineAsmBMark++;}													\}bmHolder = asmPB->lineAsmBMark;																								\if(!hex)																													\{																															\while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																								\while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}			\																															\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\}																															\else																														\{																															\while(!((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F'))){asmPB->lineAsmBMark++;}		\bmHolder = asmPB->lineAsmBMark;																																														\while((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F')){asmPB->lineAsmBMark++;}			\arg = 0;																													\j = asmPB->lineAsmBMark - bmHolder;																							\j--;																														\asmPB->lineAsmBMark = bmHolder;																								\for(;j>=0;asmPB->lineAsmBMark++,j--)																							\{																															\if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)									\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																\}																															\else																														\{																															\_pow(10,j)																													\arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x37)*(g_powrv));																\}																															\}																															\}																															\if(arg>0xFF)																												\{																															\HANDLE_ARG_ERROR																											\}																															\if(neg)																														\{																															\arg*=-1;																													\}																															\arg = arg & 0xFF;#define _ASSEMBLE_INSTRUCTION(X)									\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_24bitB(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_DESTINATION_24													\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<2);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_14bitB(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_DESTINATION_14													\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<2);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_14bitB2(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_DESTINATION_14													\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<2);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_16_6_11(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<6);		\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_16_6(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<6);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_16_11(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_11(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_11(X)									\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_16_11(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_16_21_11(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_16_21and11(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_16_21(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_16(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_16_21_11_6_1(X)						\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<6);		\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<1);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_16SR(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_SR																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_16SR_21(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_SR																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_SIMM_16(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_SIMM_16															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg);		\GET_REGISTER														\asmPB->lineAsmBMark++;												\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_SIMM(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_SIMM_16															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_16_SIMM(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_SIMM_16															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_16_21_UIMM(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_UIMM_16															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_23_21_16_11(X)						\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_CRF																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<23);	\GET_BYTE															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_23_16_11(X)							\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_CRF																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<23);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_23_21_16_SIMM(X)						\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_CRF																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<23);	\GET_BYTE															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	\GET_SIMM_16															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg);		\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_23_18(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_CRF																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<23);	\GET_CRF																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<18);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_23(X)									\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_CRF																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<23);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21(X)									\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_21_11S(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\GET_10BIT															\b = arg>>5;															\arg = (arg&0x1F)<<5;												\arg += b;															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_11S_21(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_10BIT															\b = arg>>5;															\arg = (arg&0x1F)<<5;												\arg += b;															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_12_21(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_CRM																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<12);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_17_11(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_8BIT															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<17);	\GET_REGISTER														\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<11);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_23_12(X)								\																	\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=X;				\GET_CRF																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<23);	\GET_SR																\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<12);	\INCREMENT_CODE(asmPB->asmRecord->instcount)#define _ASSEMBLE_INSTRUCTION_32bitval								\																	\GET_32BIT															\asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=(arg);			\INCREMENT_CODE(asmPB->asmRecord->instcount)void add(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000214)}void addP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000215)}void addo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000614)}void addoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000615)}void addc(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000014)}void addcP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000015)}void addco(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000414)}void addcoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000415)}void adde(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000114)}void addeP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000115)}void addeo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000514)}void addeoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000515)}void addi(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_16_SIMM(0x38000000)}void addic(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_16_SIMM(0x30000000)}void addicP(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_16_SIMM(0x34000000)}void addis(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_16_SIMM(0x3C000000)}void addme(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C0001D4)}void addmeP(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C0001D5)}void addmeo(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C0005D4)}void addmeoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C0005D5)}void addze(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C000194)}void addzeP(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C000195)}void addzeo(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C000594)}void addzeoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_21_16(0x7C000595)}void _and(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000038)}void andP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000039)}void andc(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000078)}void andcP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000079)}void andiP(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_16_21_UIMM(0x70000000)}void andisP(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_16_21_UIMM(0x74000000)}void bcctr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x4C000420)}void bcctrl(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x4C000421)}void bclr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x4C000020)}void bclrl(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x4C000021)}void cmp(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_21_16_11(0x7C000000)}void cmpi(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_23_21_16_SIMM(0x2C000000)}void cmpl(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_21_16_11(0x7C000040)}void cmpli(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_23_21_16_SIMM(0x28000000)}void cntlzw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21(0x7C000034)}void cntlzwP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21(0x7C000035)}void crand(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C000202)}void crandc(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C000102)}void creqv(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C000242)}void crnand(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C0001C2)}void crnor(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C000042)}void cror(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C000382)}void crorc(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C000342)}void crxor(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x4C000182)}void dcba(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C0005EC)}void dcbf(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C0000AC)}void dcbi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C0003AC)}void dcbst(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C00006C)}void dcbt(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C00022C)}void dcbtst(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C0001EC)}void dcbz(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C0007EC)}void divw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0003D6)}void divwP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0003D7)}void divwo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0007D6)}void divwoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0007D7)}void divwu(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000396)}void divwuP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000397)}void divwuo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000796)}void divwuoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000797)}void eciwx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00026C)}void ecowx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00036C)}void eieio(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x7C0006AC)}void eqv(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000238)}void eqvP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000239)}void extsb(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21(0x7C000774)}void extsbP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21(0x7C000775)}void extsh(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21(0x7C000734)}void extshP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21(0x7C000735)}void fabs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000210)}void fabsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000211)}void fadd(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xFC00002A)}void faddP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xFC00002B)}void fadds(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xEC00002A)}void faddsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xEC00002B)}void fcmpo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_16_11(0xFC000040)}void fcmpu(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_16_11(0xFC000000)}void fctiw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC00001C)}void fctiwP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC00001D)}void fctiwz(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC00001E)}void fctiwzP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC00001F)}void fdiv(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xFC000024)}void fdivP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xFC000025)}void fdivs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xEC000024)}void fdivsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xEC000025)}void fmadd(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00003A)}void fmaddP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00003B)}void fmadds(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC00003A)}void fmaddsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC00003B)}void fmr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000090)}void fmrP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000091)}void fmsub(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC000038)}void fmsubP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC000039)}void fmsubs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC000038)}void fmsubsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC000039)}void fmul(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6(0xFC000032)}void fmulP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6(0xFC000033)}void fmuls(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6(0xEC000032)}void fmulsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6(0xEC000033)}void fnabs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000110)}void fnabsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000111)}void fneg(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000050)}void fnegP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000051)}void fnmadd(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00003E)}void fnmaddP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00003F)}void fnmadds(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC00003E)}void fnmaddsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC00003F)}void fnmsub(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00003C)}void fnmsubP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00003D)}void fnmsubs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC00003C)}void fnmsubsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xEC00003D)}void fres(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xEC000030)}void fresP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xEC000031)}void frsp(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000018)}void frspP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000019)}void frsqrte(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000034)}void frsqrteP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC000035)}void fsel(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00002E)}void fselP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_6_11(0xFC00002F)}void fsqrt(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC00002C)}void fsqrtP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xFC00002D)}void fsqrts(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xEC00002C)}void fsqrtsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0xEC00002D)}void fsub(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xFC000028)}void fsubP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xFC000029)}void fsubs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xEC000028)}void fsubsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0xEC000029)}void icbi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_11(0x7C0007AC)}void isync(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x4C00012C)}void lbz(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x88000000)}void lbzu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x8C000000)}void lbzux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0000EE)}void lbzx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0000AE)}void lfd(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xC8000000)}void lfdu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xCC000000)}void lfdux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0004EE)}void lfdx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0004AE)}void lfs(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xC0000000)}void lfsu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xC4000000)}void lfsux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00046E)}void lfsx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00042E)}void lha(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xA8000000)}void lhau(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xAC000000)}void lhaux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0002EE)}void lhax(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0002AE)}void lhbrx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00062C)}void lhz(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xA0000000)}void lhzu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xA4000000)}void lhzux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00026E)}void lhzx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00022E)}void lmw(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xB8000000)}void lswi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0004AA)}void lswx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00042A)}void lwarx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000028)}void lwbrx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00042C)}void lwz(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;//_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x80000000)asmPB->asmRecord->insts[asmPB->asmRecord->instcount]=0x80000000;				GET_REGISTER														asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<21);neg=false;hex=false;off=false;txt=false;																					_FindNumeric2(asmPB->lineAsmBuffer,asmPB->lineAsmBMark)																			if(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39))								{																															if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='-'){neg=true;asmPB->lineAsmBMark++;}													if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='$'){hex=true;asmPB->lineAsmBMark++;}													if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='*'){off=true;asmPB->lineAsmBMark++;}													if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]=='\''){txt=true;asmPB->lineAsmBMark++;}												}bmHolder = asmPB->lineAsmBMark;																								if(!hex && !off && !txt)																									{																															while(!(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)){asmPB->lineAsmBMark++;}		bmHolder = asmPB->lineAsmBMark;																								while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30 && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39){asmPB->lineAsmBMark++;}																																		arg = 0;																													j = asmPB->lineAsmBMark - bmHolder;																							j--;																														asmPB->lineAsmBMark = bmHolder;																								for(;j>=0;asmPB->lineAsmBMark++,j--)																							{																															_pow(10,j)																													arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																}																															}																															else if(hex)																												{																															while(!((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F'))){asmPB->lineAsmBMark++;}		bmHolder = asmPB->lineAsmBMark;																																														while((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)||(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>='A'&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<='F')){asmPB->lineAsmBMark++;}			arg = 0;																													j = asmPB->lineAsmBMark - bmHolder;																							j--;																														asmPB->lineAsmBMark = bmHolder;																								for(;j>=0;asmPB->lineAsmBMark++,j--)																							{																															if(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]>=0x30&&asmPB->lineAsmBuffer[asmPB->lineAsmBMark]<=0x39)									{																															_pow(0x10,j)																													arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x30)*(g_powrv));																}																															else																														{																															_pow(0x10,j)																													arg += ((asmPB->lineAsmBuffer[asmPB->lineAsmBMark]-0x37)*(g_powrv));																}																															}																															}																															else if(off)																												{																																while(asmPB->lineAsmBuffer[asmPB->lineAsmBMark]!=0x0D && asmPB->lineAsmBuffer[asmPB->lineAsmBMark]!='('){asmPB->lineAsmBMark++;}				j = asmPB->lineAsmBMark-bmHolder;																									asmPB->lineAsmBMark = bmHolder;																									asmPB->name = NewPtr(j+1);																										for(bmHolder=0;bmHolder<j;bmHolder++,asmPB->lineAsmBMark++)																		{asmPB->name[bmHolder] = asmPB->lineAsmBuffer[asmPB->lineAsmBMark];}																	asmPB->name[bmHolder]=0;																										asmPB->curr = asmPB->dataV;																										while(asmPB->curr)																												{																																tbv=MyCStrCmp(asmPB->name,asmPB->curr->name);																					if(tbv){break;}																													asmPB->curr = asmPB->curr->next;																								}																																if(tbv){arg=asmPB->curr->off;}																									else	{	HANDLE_MV_ERROR	}																							DisposePtr(asmPB->name);																									}																																else if(txt)																													{																																arg=0;																															arg+=(asmPB->lineAsmBuffer[asmPB->lineAsmBMark])<<8;asmPB->lineAsmBMark++;																arg+=asmPB->lineAsmBuffer[asmPB->lineAsmBMark];asmPB->lineAsmBMark+=2;																	}																																if(arg>0xFFFF){																															HANDLE_ARG_ERROR																											}																			if(neg)																														{																															arg*=-1;																													}																															arg = arg & 0xFFFF;													asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg);		GET_REGISTER														asmPB->lineAsmBMark++;												asmPB->asmRecord->insts[asmPB->asmRecord->instcount]+=(arg<<16);	INCREMENT_CODE(asmPB->asmRecord->instcount)}void lwzu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x84000000)}void lwzux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00006E)}void lwzx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00002E)}void mcrf(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_18(0x4C000000)}void mcrfs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_18(0xFC000080)}void mcrxr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23(0x7C000400)}void mfcr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0x7C000026)}void mffs(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0xFC00048E)}void mffsP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0xFC00048F)}void mfmsr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0x7C0000A6)}void mfspr(AssemblyPBlock* asmPB){long arg,j,bmHolder;long b;_ASSEMBLE_INSTRUCTION_21_11S(0x7C0002A6)}void mfsr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16SR(0x7C0004A6)}void mfsrin(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0x7C000526)}void mftb(AssemblyPBlock* asmPB){long arg,j,bmHolder;long b;_ASSEMBLE_INSTRUCTION_21_11S(0x7C0002E6)}void mtcrf(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex;_ASSEMBLE_INSTRUCTION_12_21(0x7C000120)}void mtfsb0(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0xFC00008C)}void mtfsb0P(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0xFC00008D)}void mtfsb1(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0xFC00004C)}void mtfsb1P(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0xFC00004D)}void mtfsf(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_17_11(0xFC00058E)}void mtfsfP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_17_11(0xFC00058F)}void mtfsfi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_12(0xFC00010C)}void mtfsfiP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_23_12(0xFC00010D)}void mtmsr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0x7C000124)}void mtspr(AssemblyPBlock* asmPB){long arg,j,bmHolder;long b;_ASSEMBLE_INSTRUCTION_11S_21(0x7C0003A6)}void mtsr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16SR_21(0x7C0001A4)}void mtsrin(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_11(0x7C0001E4)}void mulhw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000096)}void mulhwP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000097)}void mulhwu(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000016)}void mulhwuP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000017)}void mulli(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_16_SIMM(0x1C000000)}void mullw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0001D6)}void mullwP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0001D7)}void mullwo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0005D6)}void mullwoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0005D7)}void nand(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C0003B8)}void nandP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C0003B9)}void neg(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0000D0)}void negP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0000D1)}void nego(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0004D0)}void negoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0004D1)}void nor(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C0000F8)}void norP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C0000F9)}void _or(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000378)}void orP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000379)}void orc(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000338)}void orcP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000339)}void ori(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_16_21_UIMM(0x60000000)}void oris(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_16_21_UIMM(0x64000000)}void rfi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x4C000064)}void rlwimi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11_6_1(0x50000000)}void rlwimiP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11_6_1(0x50000001)}void rlwinm(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11_6_1(0x54000000)}void rlwinmP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11_6_1(0x54000001)}void rlwnm(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11_6_1(0x5C000000)}void rlwnmP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11_6_1(0x5C000001)}void sc(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x44000002)}void slw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000030)}void slwP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000031)}void sraw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000630)}void srawP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000631)}void srawi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000670)}void srawiP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000671)}void srw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000430)}void srwP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000431)}void stb(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x98000000)}void stbu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x9C000000)}void stbux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0001EE)}void stbx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0001AE)}void stfd(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xD8000000)}void stfdu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xDC000000)}void stfdux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0005EE)}void stfdx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0005AE)}void stfiwx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0007AE)}void stfs(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xD0000000)}void stfsu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xD4000000)}void stfsux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00056E)}void stfsx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00052E)}void sth(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xB0000000)}void sthbrx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00072C)}void sthu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xB4000000)}void sthux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00036E)}void sthx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00032E)}void stmw(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0xBC000000)}void stswi(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C0005AA)}void stswx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00052A)}void stw(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x90000000)}void stwbrx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00052C)}void stwcxP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00012D)}void stwu(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x94000000)}void stwux(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00016E)}void stwx(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C00012E)}void subf(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000050)}void subfP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000051)}void subfo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000450)}void subfoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000451)}void subfc(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000010)}void subfcP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000011)}void subfco(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000410)}void subfcoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000411)}void subfe(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000110)}void subfeP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000111)}void subfeo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000510)}void subfeoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000511)}void subfic(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_16_SIMM(0x20000000)}void subfme(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0001D0)}void subfmeP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0001D1)}void subfmeo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0005D0)}void subfmeoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C0005D1)}void subfze(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C000190)}void subfzeP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C000191)}void subfzeo(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C000590)}void subfzeoP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16(0x7C000591)}void sync(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x7C0004AC)}void tlbia(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x7C0002E4)}void tlbie(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_11(0x7C000264)}void tlbsync(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x7C00046C)}void tw(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21_16_11(0x7C000008)}void twi(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_16_SIMM(0x0C000000)}void _xor(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000278)}void xorP(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21_11(0x7C000279)}void xori(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_16_21_UIMM(0x68000000)}void xoris(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_16_21_UIMM(0x6C000000)}void b(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_24bitB(0x48000000)}void ba(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_24bitB(0x48000002)}void bl(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_24bitB(0x48000001)}void bla(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_24bitB(0x48000003)}void bc(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB(0x40000000)}void bca(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB(0x40000002)}void bcl(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB(0x40000001)}void bcla(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB(0x40000003)}void nop(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x60000000)}void blr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x4E800020)}void blrl(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x4E800021)}void dc(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_32bitval}void mflr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0x7C0802A6)}void mtlr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0x7C0803A6)}void la(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM_16(0x38000000)}void li(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,off;_ASSEMBLE_INSTRUCTION_21_SIMM(0x38000000)}void mr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_16_21and11(0x7C000378)}void mtctr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0x7C0903A6)}void bctr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x4E800420)}void bctrl(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION(0x4E800421)}void bdnz(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x42000000)}void bdnza(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x42000002)}void bdnzl(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x42000001)}void bdnzla(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x42000003)}void mfctr(AssemblyPBlock* asmPB){long arg,j,bmHolder;_ASSEMBLE_INSTRUCTION_21(0x7C0902A6)}//page 642void blt(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41800000)}void bltl(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41800001)}void blta(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41800002)}void bltla(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41800003)}void ble(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40810000)}void blea(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40810002)}void blel(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40810001)}void blela(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40810003)}void beq(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41820000)}void beqa(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41820002)}void beql(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41820001)}void beqla(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41820003)}void bge(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40800000)}void bgea(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40800002)}void bgel(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40800001)}void bgela(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40800003)}void bgt(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41810000)}void bgta(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41810002)}void bgtl(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41810001)}void bgtla(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x41810003)}void bne(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40820000)}void bnea(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40820002)}void bnel(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40820001)}void bnela(AssemblyPBlock* asmPB){long arg,j,bmHolder;Boolean neg,hex,label;_ASSEMBLE_INSTRUCTION_14bitB2(0x40820003)}