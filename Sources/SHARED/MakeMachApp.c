Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************/#include "ProjectHeaders.h"struct Mach_Segments{segment_command 		segment;struct Mach_Segments	*next;};typedef struct Mach_Segments Mach_Segments;struct Mach_App{Mach_Segments			*segments;Mach_Segments			**segment;};typedef struct Mach_App Mach_App;void HandleMachInfoCommand(unsigned char *infoData,long *bMarker,long fileSize);void Assemble_LC_SEGMENT(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_SYMTAB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_SYMSEG(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_THREAD(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_UNIXTHREAD(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_LOADFVMLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_IDFVMLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_IDENT(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_FVMFILE(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_PREPAGE(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_DYSYMSTAB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_LOAD_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_ID_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_LOAD_DYLINKER(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_ID_DYLINKER(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_PREBOUND_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_ROUTINES(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_SUB_FRAMEWORK(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_SUB_UMBRELLA(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_SUB_CLIENT(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_SUB_LIBRARY(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_TWOLEVEL_HINTS(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_PREBIND_CKSUM(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);void Assemble_LC_LOAD_WEAK_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app);#define WHITE_SPACE(X,Y)	\(							\(X[Y]=='\t')				\||							\(X[Y]==' ')					\||							\(X[Y]=='\r')				\||							\(X[Y]=='\n')				\||							\(X[Y]==',')					\)#define GET_TERM(X,Y)			\i=1;							\while(!WHITE_SPACE(X,Y))		\{								\dataHolder[i] = X[Y];			\i++;							\Y++;							\}								\dataHolder[0] = i-1;void MakeMachApp(AssemblerRecord	*asmRecord){FSSpec				appFolder,appBinary;long				createdDirID;FSRef				fsRef;FSCatalogInfo		catInfo;Str255				targetFolder;mach_header			machHeader;segment_command		TEXT_Segment;section				text_Section;thread_command		threadCommand;ppc_thread_state	*ppcThreadState;long				alignCount,totalWritten;long				i,bMarker;unsigned long		count;unsigned char		byte,*infoData;void				*appRef,*machInfoRef;long				fileSize;void				*err;Str255				dataHolder;/*MyPStrAdd(asmRecord->key->target,"\p.app",targetFolder);#ifdef __POWERPC__FSMakeFSSpec(((FSSpec*)asmRecord->parSpec)->vRefNum,((FSSpec*)asmRecord->parSpec)->parID,targetFolder,&appFolder);FSpDirCreate(&appFolder,smSystemScript,&createdDirID);FSpMakeFSRef(&appFolder,&fsRef);FSGetCatalogInfo(&fsRef,kFSCatInfoNodeID,&catInfo,NULL,NULL,NULL);FSMakeFSSpec(((FSSpec*)asmRecord->parSpec)->vRefNum,catInfo.nodeID,"\pContents",&appFolder);FSpDirCreate(&appFolder,smSystemScript,&createdDirID);FSpMakeFSRef(&appFolder,&fsRef);FSGetCatalogInfo(&fsRef,kFSCatInfoNodeID,&catInfo,NULL,NULL,NULL);//FSMakeFSSpec(appFolder.vRefNum,catInfo.nodeID,"\pInfo.plist",&appBinary);//FSpCreate(appBinary,'????','TEXT',smSystemScript);FSMakeFSSpec(((FSSpec*)asmRecord->parSpec)->vRefNum,catInfo.nodeID,"\pMacOS",&appFolder);FSpDirCreate(&appFolder,smSystemScript,&createdDirID);FSpMakeFSRef(&appFolder,&fsRef);FSGetCatalogInfo(&fsRef,kFSCatInfoNodeID,&catInfo,NULL,NULL,NULL);FSMakeFSSpec(appFolder.vRefNum,catInfo.nodeID,asmRecord->key->target,&appBinary);FSpCreate(&appBinary,0,0,smSystemScript);#endif*/err = FSpOpenDF(asmRecord->key->machinfo,fsRdWrPerm,&machInfoRef);if(CheckError_FSpOpenDF(err)){DebugFunction("\pFile System Error");}GetEOF(machInfoRef,&fileSize);infoData = (unsigned char*)NewPtr(fileSize);count=fileSize;FSRead(machInfoRef,&count,infoData);FSClose(machInfoRef);bMarker=0;while(bMarker<=fileSize){		switch(infoData[bMarker])		{		case ' ' :		case '\t':		case '\n':		case '\r':bMarker++;break;		case '#':while(infoData[bMarker]!=0x0D){bMarker++;}break;		case '@':				{				bMarker++;				GET_TERM(infoData,bMarker)				if(MyPStrCmp(dataHolder,"\pcommand:"))				{				HandleMachInfoCommand(infoData,&bMarker,fileSize);				}				break;				}		default: DebugFunction("\pUnknown MachInfo command");break;		}}alignCount=(4096 - (sizeof(mach_header)+(sizeof(segment_command)+sizeof(section)+sizeof(thread_command)+sizeof(ppc_thread_state)+(asmRecord->instcount*4)) % 4096));machHeader.magic		=	MH_MAGIC;machHeader.cputype		=	CPU_TYPE_POWERPC;machHeader.cpusubtype	=	CPU_SUBTYPE_POWERPC_ALL;machHeader.filetype		=	MH_EXECUTE;machHeader.ncmds		=	2;machHeader.sizeofcmds	=	sizeof(segment_command)+sizeof(section)+sizeof(thread_command)+sizeof(ppc_thread_state);machHeader.flags		=	MH_NOUNDEFS;TEXT_Segment.cmd		=	LC_SEGMENT;TEXT_Segment.cmdsize	=	sizeof(segment_command)+sizeof(section);for(i=0;i<sizeof("__TEXT");i++){TEXT_Segment.segname[i] = "__TEXT"[i];}TEXT_Segment.vmaddr		=	0;TEXT_Segment.vmsize		=	sizeof(mach_header)+sizeof(segment_command)+sizeof(section)+sizeof(thread_command)+sizeof(ppc_thread_state)+(asmRecord->instcount*4)+alignCount;;TEXT_Segment.fileoff	=	0;TEXT_Segment.filesize	=	sizeof(mach_header)+sizeof(segment_command)+sizeof(section)+sizeof(thread_command)+sizeof(ppc_thread_state)+(asmRecord->instcount*4)+alignCount;TEXT_Segment.maxprot	=	VM_PROT_EXECUTE+VM_PROT_WRITE+VM_PROT_READ;TEXT_Segment.initprot	=	VM_PROT_EXECUTE+VM_PROT_READ;TEXT_Segment.nsects		=	1;TEXT_Segment.flags		=	SG_NORELOC;for(i=0;i<sizeof("__text");i++){text_Section.sectname[i] = "__text"[i];}for(i=0;i<sizeof("__TEXT");i++){text_Section.segname[i] = "__TEXT"[i];}text_Section.addr		=	sizeof(mach_header)+sizeof(segment_command)+sizeof(section)+sizeof(thread_command)+sizeof(ppc_thread_state);text_Section.size		=	(asmRecord->instcount*4);text_Section.offset		=	sizeof(mach_header)+sizeof(segment_command)+sizeof(section)+sizeof(thread_command)+sizeof(ppc_thread_state);text_Section.align		=	2;text_Section.reloff		=	0;text_Section.nreloc		=	0;text_Section.flags		=	S_REGULAR+S_ATTR_PURE_INSTRUCTIONS;text_Section.reserved1	=	0;text_Section.reserved2	=	0;threadCommand.cmd		=	LC_UNIXTHREAD;threadCommand.cmdsize	=	sizeof(thread_command)+sizeof(ppc_thread_state);threadCommand.flavor	=	PPC_THREAD_STATE;threadCommand.count		=	40;ppcThreadState 			= 	(ppc_thread_state*)NewPtrClear(sizeof(ppc_thread_state));ppcThreadState->srr0	=	sizeof(mach_header)+sizeof(segment_command)+sizeof(section)+sizeof(thread_command)+sizeof(ppc_thread_state);totalWritten=0;FSpOpenDF(&appBinary,fsRdWrPerm,&appRef);count = sizeof(mach_header);FSWrite(appRef,&count,&machHeader);totalWritten+=count;count = sizeof(segment_command);FSWrite(appRef,&count,&TEXT_Segment);totalWritten+=count;count = sizeof(section);FSWrite(appRef,&count,&text_Section);totalWritten+=count;count = sizeof(thread_command);FSWrite(appRef,&count,&threadCommand);totalWritten+=count;count = sizeof(ppc_thread_state);FSWrite(appRef,&count,ppcThreadState);totalWritten+=count;count = (asmRecord->instcount*4);FSWrite(appRef,&count,asmRecord->insts);totalWritten+=count;byte=0;for(i=0;i<alignCount;i++){count = 1;FSWrite(appRef,&count,&byte);totalWritten+=count;}SetEOF(appRef,totalWritten);FSClose(appRef);}void HandleMachInfoCommand(unsigned char *infoData,long *bMarker,long fileSize){long			i;Str255			dataHolder;long			machInfoCommand;Mach_App		mach_app;mach_app.segment = &mach_app.segments;i=1;while((infoData[(*bMarker)]==' '||infoData[(*bMarker)]=='\t')&&((*bMarker)<=fileSize)){(*bMarker)++;}while(infoData[(*bMarker)]!=' '&&infoData[(*bMarker)]!='\t'&&infoData[(*bMarker)]!='\r'&&infoData[(*bMarker)]!='\n'&&((*bMarker)<=fileSize)){dataHolder[i] = infoData[(*bMarker)];i++;(*bMarker)++;}dataHolder[0] = i-1;if(MyPStrCmp(dataHolder,"\pLC_SEGMENT")){Assemble_LC_SEGMENT(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_SYMTAB")){Assemble_LC_SYMTAB(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_SYMSEG")){Assemble_LC_SYMSEG(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_THREAD")){Assemble_LC_THREAD(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_UNIXTHREAD")){Assemble_LC_UNIXTHREAD(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_LOADFVMLIB")){Assemble_LC_LOADFVMLIB(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_IDFVMLIB")){Assemble_LC_IDFVMLIB(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_IDENT")){Assemble_LC_IDENT(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_FVMFILE")){Assemble_LC_FVMFILE(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_PREPAGE")){Assemble_LC_PREPAGE(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_DYSYMTAB")){Assemble_LC_DYSYMSTAB(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_LOAD_DYLIB")){Assemble_LC_LOAD_DYLIB(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_ID_DYLIB")){Assemble_LC_ID_DYLIB(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_LOAD_DYLINKER")){Assemble_LC_LOAD_DYLINKER(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_ID_DYLINKER")){Assemble_LC_ID_DYLINKER(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_PREBOUND_DYLIB")){Assemble_LC_PREBOUND_DYLIB(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_ROUTINES")){Assemble_LC_ROUTINES(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_SUB_FRAMEWORK")){Assemble_LC_SUB_FRAMEWORK(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_SUB_UMBRELLA")){Assemble_LC_SUB_UMBRELLA(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_SUB_CLIENT")){Assemble_LC_SUB_CLIENT(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_SUB_LIBRARY")){Assemble_LC_SUB_LIBRARY(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_TWOLEVEL_HINTS")){Assemble_LC_TWOLEVEL_HINTS(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_PREBIND_CKSUM")){Assemble_LC_PREBIND_CKSUM(infoData,bMarker,fileSize,&mach_app);}else if(MyPStrCmp(dataHolder,"\pLC_LOAD_WEAK_DYLIB")){Assemble_LC_LOAD_WEAK_DYLIB(infoData,bMarker,fileSize,&mach_app);}else{DebugFunction("\pUnkown MachInfo Command");}}void Assemble_LC_SEGMENT(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){long			i;Str255			dataHolder;Boolean			process_segment;*mach_app->segment = (Mach_Segments*)NewPtr(sizeof(Mach_Segments));process_segment = true;while((infoData[(*bMarker)]==' '||infoData[(*bMarker)]=='\t'||infoData[(*bMarker)]=='{'||infoData[(*bMarker)]=='\n'||infoData[(*bMarker)]=='\r')&&((*bMarker)<=fileSize)){(*bMarker)++;}while(process_segment){	while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}	GET_TERM(infoData,(*bMarker))	if(MyPStrCmp(dataHolder,"\pname:"))	{		while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}		GET_TERM(infoData,(*bMarker))		if(dataHolder[0]>16){DebugFunction("\pmach segment name exceeds 16 char limit");}		for(i=0;i<dataHolder[0];i++){(*mach_app->segment)->segment.segname[i]=dataHolder[i+1];}		for (;i<16;i++){(*mach_app->segment)->segment.segname[i]=0;}	}	else if(MyPStrCmp(dataHolder,"\pvmaddr:"))	{	while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}	GET_TERM(infoData,(*bMarker))	(*mach_app->segment)->segment.vmaddr = CharHexToDec(dataHolder);	}	else if(MyPStrCmp(dataHolder,"\pvmsize:"))	{	while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}	GET_TERM(infoData,(*bMarker))	(*mach_app->segment)->segment.vmsize = CharHexToDec(dataHolder);	}	else if(MyPStrCmp(dataHolder,"\pfileoff:"))	{	while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}	GET_TERM(infoData,(*bMarker))	(*mach_app->segment)->segment.fileoff = CharHexToDec(dataHolder);	}	else if(MyPStrCmp(dataHolder,"\pfilesize:"))	{	while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}	GET_TERM(infoData,(*bMarker))	(*mach_app->segment)->segment.filesize = CharHexToDec(dataHolder);	}	else if(MyPStrCmp(dataHolder,"\pmaxprot:"))	{		(*mach_app->segment)->segment.maxprot=0;		while(infoData[(*bMarker)]!='\r' && infoData[(*bMarker)]!='\n')		{		while(infoData[(*bMarker)]==' ' || infoData[(*bMarker)]=='\t' || infoData[(*bMarker)]==','){(*bMarker)++;}		GET_TERM(infoData,(*bMarker))		if(MyPStrCmp(dataHolder,"\pVM_PROT_NONE")){(*mach_app->segment)->segment.maxprot+=0;}		else if(MyPStrCmp(dataHolder,"\pVM_PROT_READ")){(*mach_app->segment)->segment.maxprot+=1;}		else if(MyPStrCmp(dataHolder,"\pVM_PROT_WRITE")){(*mach_app->segment)->segment.maxprot+=2;}		else if(MyPStrCmp(dataHolder,"\pVM_PROT_EXECUTE")){(*mach_app->segment)->segment.maxprot+=4;}		else{DebugFunction("\punknown vm protection level");}		}	}	else if(MyPStrCmp(dataHolder,"\pinitprot:"))	{	while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}	GET_TERM(infoData,(*bMarker))	}	else if(MyPStrCmp(dataHolder,"\pflags:"))	{	while(WHITE_SPACE(infoData,(*bMarker))){(*bMarker)++;}	GET_TERM(infoData,(*bMarker))	}}}void Assemble_LC_SYMTAB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_SYMSEG(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_THREAD(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_UNIXTHREAD(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_LOADFVMLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_IDFVMLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_IDENT(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_FVMFILE(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_PREPAGE(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_DYSYMSTAB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_LOAD_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_ID_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_LOAD_DYLINKER(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_ID_DYLINKER(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_PREBOUND_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_ROUTINES(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_SUB_FRAMEWORK(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_SUB_UMBRELLA(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_SUB_CLIENT(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_SUB_LIBRARY(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_TWOLEVEL_HINTS(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_PREBIND_CKSUM(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}void Assemble_LC_LOAD_WEAK_DYLIB(unsigned char *infoData,long *bMarker,long fileSize,Mach_App *mach_app){}long CharHexToDec(Str255 bytes){long			returnVal,position,value;long			i,j,k;returnVal=0;position=0;for(i=bytes[0];i>2;i--,position++){if(bytes[i]>='0' && bytes[i]<='9'){value = bytes[i]-0x30;}else if(bytes[i]>='A' && bytes[i]<='F'){value = bytes[i]-0x37;}else if(bytes[i]>='a' && bytes[i]<='f'){value = bytes[i]-0x57;}for(j=0,k=1;j<position;j++){k*=16;}returnVal += value*k;}return returnVal;}