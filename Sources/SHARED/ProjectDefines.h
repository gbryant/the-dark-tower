Copyright 2016 Gregory BryantLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License./***********************************************************************//*#define swaplong(X)					\gA = *X;							\gB = *((unsigned char*)X+1);		\gC = *((unsigned char*)X+2);		\gD = *((unsigned char*)X+3);		\*X = (gD<<24)+(gC<<16)+(gB<<8)+gA;#define swapshort(X)				\gA = *X;							\gB = *((unsigned char*)X+1);		\*X = (gB<<16)+gA;*/enum ASKS_ControlValues {						kASKS_DontSave=1,						kASKS_Cancel,						kASKS_Save						};enum SIIN_ControlValues {						kSIIN_Ass=1,						kSIIN_AssResult,						kSIIN_Diss,						kSIIN_DissResult,						kSIIN_ErrorMessage						};												enum MAIN_ControlValues {						kMAIN_ProgressBar=1,						kMAIN_StatusText,						kMAIN_Tabs,						kMAIN_CancelText						};						enum PREF_ControlValues {						kPREF_UseLabeledBranches=1,						kPREF_ProcedureNames,						kPREF_SpeedierBranchSort						};enum ASSM_ControlValues {						kASSM_Target=1,						kASSM_GoButton,						kASSM_New,						kASSM_Open,						kASSM_Save,						kASSM_SaveAs												};enum DISS_ControlValues {						kDISS_TargetIcon=1,						kDISS_TargetName,						kDISS_GoButton						};enum EXPL_ControlValues {						kEXPL_TargetIcon=1,						kEXPL_TargetName,						kEXPL_GoButton						};						enum RLOC_ControlValues {						kRLOC_DataBrowser=1,						kRLOC_Add,						kRLOC_Delete,						kRLOC_MessageLabel,						kRLOC_MessageText						};enum SRC_ControlValues {						kSRC_HIView=1,						kSRC_MessageText,						kSRC_ScrollBar,						kSRC_CloneWindow,						kSRC_OffsetBox,						kSRC_SearchMenu,						kSRC_SearchBox												};enum MACH_ControlValues {						kMACH_NewSource=1,						kMACH_EditSource,						kMACH_SelectSource,						kMACH_SourceName,						kMACH_NewMachInfo,						kMACH_EditMachInfo,						kMACH_SelectMachInfo,						kMACH_MachInfoName,						kMACH_Product						};enum CFRG_ControlValues {						kCFRG_NewSource=1,						kCFRG_EditSource,						kCFRG_SelectSource,						kCFRG_SourceName,						kCFRG_NewData,						kCFRG_EditData,						kCFRG_SelectData,						kCFRG_DataName,						kCFRG_DataExports,						kCFRG_DataExportCount,						kCFRG_NewRelocation,						kCFRG_EditRelocation,						kCFRG_SelectRelocation,						kCFRG_RelocationName,						kCFRG_NewResource,						kCFRG_EditResource,						kCFRG_SelectResource,						kCFRG_ResourceName,						kCFRG_main,						kCFRG_init,						kCFRG_term,						kCFRG_Product,						kCFRG_Type,						kCFRG_Creator,						kCFRG_Comments						};																								enum MAIN_TabValues {					kASSM_Tab=1,					kDISS_Tab,					kEXPL_Tab					};					enum RLOC_MenuValues {					kInitial_RELOC_Choice=1,										kDDAT=3,										kCODE=6,					kDATA,					kDESC,					kDSC2,					kVTBL,					kSYMR,										kSYMB=14,					kCDIS,					kDTIS,					kSECN,					kDELT,					kRPT,					kLABS,					kLSYM,					kLRPT,										kLSEC0=25,					kLSEC1,					kLSEC2										};										#define kCreatorCode 'МыµМ'#define kArgumentColumn 'ARGU'#define kMnemonicColumn 'MNEM'#define		kWindowDirty	'wdrt'#define		kWindowAction	'wact'#define		kWindowType		'wtyp'#define		kSaveSheet		'svst'#define		kFileReference	'frfs'#define		kSrcDataView	'srcd'#define		kSrcScrollBar	'srcv'#define		kSrcWindow		'srcw'#define		kSrcBrowser		'srcb'#define		kSearchMenu		'scmn'#define		kSearchType			'scht'#define		kMnemonicSearch		3#define		kArgumentSearch		4#define		kHexadecimalSearch	5enum WindowTypes	{					kRelocationEditor=1,					kSourceEditor,					kPreferences,					kMain,					kAbout,					kAskSave,					kDebug,					kSingleInstruction					};enum WindowActions	{					kExisting=0,					kOpening=1,					kCreating					};#define		kControlOwner	'cnow'#define		kControlType	'ctyp'#define kDelete 8#define kRightArrow 29#define kLeftArrow 28#define kDownArrow 31#define kUpArrow 30enum EditTextOwners {					kPEF_Reloc=1,					kASSM_Cfrg,					kPPC_Asm,					kSIIN,					kSRC_Edit					};enum SRCEditEditTextTypes						{						kSearchField,						kAddressField						};																	enum SIINEditTextTypes						{						kAss,						kAssResult,						kDiss,						kDissResult						};					enum ASSMCfrgEditTextTypes	{							kSourcePath=1,							kDataPath,							kRelocationPath,							kResourcePath,							kOffsetMain,							kOffsetInit,							kOffsetTerm,							kProduct,							kType,							kCreator,							kComments							};enum PEF_Reloc_ETextLimits {					k4BIT=1,					k4BIT_M1,					k6BIT,					k8BIT,					k8BIT_M1,					k9BIT,					k9BIT_M1,					k12BIT_M1,					k22BIT,					k26BIT					};						#define BUFFER_SIZE 2000000#define DATA_BUFFER_SIZE 500000 //how many longs?.....* sizeof(long) for size in bytes#define false 0#define true 1#define kBefore 1#define kAfter 2#define		PEF_CONTAINER_HEADER_OFFSET			(0L)#define 	SECTION_HEADER_OFFSET			 	(sizeof(PEFContainerHeader))#define		LOADER_INFO_HEADER_OFFSET			(pefData->container.sectionHeader[z].containerOffset)#define		IMPORTED_LIBRARY_OFFSET				((pefData->container.sectionHeader[z].containerOffset) + sizeof(PEFLoaderInfoHeader))#define		IMPORTED_SYMBOL_OFFSET				((pefData->container.sectionHeader[z].containerOffset) + sizeof(PEFLoaderInfoHeader) + (pefData->container.loaderInfoHeader.importedLibraryCount) * (sizeof(PEFImportedLibrary)))#define		LOADER_RELOCATION_HEADER_OFFSET		((pefData->container.sectionHeader[z].containerOffset) + sizeof(PEFLoaderInfoHeader) + (pefData->container.loaderInfoHeader.importedLibraryCount) * (sizeof(PEFImportedLibrary)) + (pefData->container.loaderInfoHeader.totalImportedSymbolCount * sizeof(PEFImportedSymbol)))//// Section characteristics.////      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.//                                           0x00002000  // Reserved.//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits in the TLB entries for this section.#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP#define IMAGE_SCN_MEM_FARDATA                0x00008000//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000#define IMAGE_SCN_MEM_PURGEABLE              0x00020000#define IMAGE_SCN_MEM_16BIT                  0x00020000#define IMAGE_SCN_MEM_LOCKED                 0x00040000#define IMAGE_SCN_MEM_PRELOAD                0x00080000#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //// Unused                                    0x00F00000#define IMAGE_SCN_ALIGN_MASK                 0x00F00000#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.#define _FindAlpha(X,Y)											\					while   (									\								!(								\								((X[Y]>='a') && (X[Y]<='z'))	\								||								\								((X[Y]>='A') && (X[Y]<='Z'))	\								)								\							)									\																\							{									\								if(X[Y]=='#')					\								{								\									while(X[Y]!=0x0D)			\									{							\									INCREMENT(Y);				\									}							\								}								\								INCREMENT(Y);					\							}							#define _FindNumeric(X,Y)										\					while   (									\								!(								\								((X[Y]>='0') && (X[Y]<='9'))	\								||								\								(X[Y]=='-')						\								||								\								(X[Y]=='$')						\								)								\							)									\																\							{									\							Y++;								\							}#define _FindNumeric2(X,Y)										\					while   (									\								!(								\								((X[Y]>='0') && (X[Y]<='9'))	\								||								\								(X[Y]=='-')						\								||								\								(X[Y]=='$')						\								||								\								(X[Y]=='*')						\								||								\								(X[Y]=='\'')					\								)								\							)									\																\							{									\							Y++;								\							}						#define _FindFieldValue(X,Y)									\					while   (									\								!(								\								((X[Y]>='0') && (X[Y]<='9'))	\								||								\								(X[Y]=='a')						\								||								\								(X[Y]=='$')						\								)								\							)									\																\							{									\							Y++;								\							}#define _FindWhiteSpace(X,Y)								\					while	(								\								!(							\								(X[Y]=='\t')				\								||							\								(X[Y]=='\r')				\								||							\								(X[Y]=='\n')				\								||							\								(X[Y]==' ')					\								||							\								(X[Y]=='#')					\								||							\								(X[Y]==',')					\								||							\								(X[Y]=='|')					\								||							\								(X[Y]==']')					\								||							\								(X[Y]==':')					\								)							\							)								\															\							{								\							Y++;							\							}#define _FindWhiteSpace2(X,Y)								\					while	(								\								!(							\								(X[Y]=='\t')				\								||							\								(X[Y]=='\r')				\								||							\								(X[Y]=='\n')				\								||							\								(X[Y]==' ')					\								||							\								(X[Y]=='#')					\								||							\								(X[Y]==',')					\								||							\								(X[Y]=='|')					\								||							\								(X[Y]==']')					\								)							\							)								\															\							{								\							Y++;							\							}#define _FindQuote(X,Y)										\					while	(								\								!(							\								(X[Y]=='"')					\								)							\							)								\															\							{								\							Y++;							\							}							#define _Find(X,Y,Z)					\				while	(				\							!(			\							(Y[Z]==X)	\							)			\						)				\										\						{				\						Z++;			\						}				